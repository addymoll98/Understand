Chunk: 6.1.  The Development Organization should design the system to protect Critical 
Software and Critical Data from inadvertent or intentional manipulation during transport from one 
secure enclave to another secure enclave.
Chunk: 6.2.1.  The transmission of Critical Software or Critical Data outside of immediate control of 
the weapon system can become a safety concern if the data is susceptible to intentional or 
accidental manipulation.
Chunk: 6.2.2.  The software developer shall use protocols that protect the transmission of Critical 
Software via over-the-air broadcasts or transmission over media outside of immediate control 
of the weapon system from inadvertent or intentional corruption, through encryption, digital 
signatures, or similar methods. (T-1) Verification activities should prove that protocol 
protection mechanisms protect Critical Software during transmission of over-the-air 
broadcasts or transmission over media outside of immediate control of the weapon system. If 
the weapon system stores the Critical Software in an incorruptible manner, and the weapon 
system verifies the Critical Software during each restart, then this requirement no longer 
applies. AFSEC/SEWN prefers encryption as the mechanism for protocol protection, but the 
NSA should approve the encryption methodology. If the software does not properly meet this 
requirement, then any system that could modify the Critical Software may fall under NSCCA 
guidelines.
Chunk: 6.3.  Physical Media.  The operators may use physical data storage such as DVD-ROMs or 
portable flash drives to store and transport Critical Software and Critical Data between weapon 
systems or within a weapon system with the following requirements:
6.3.1.  The software developer shall use standard, commercially available protocols or 
military-approved protocols to access physical data storage containing Critical Software or 
Critical Data. (T-1) Verification activities should prove physical data storage access protocols 
are commercially available or military-approved.
6.3.2.  The software developer shall ensure that the software validates all low-level data 
through standard mathematically deterministic error-detecting and error-correcting operations 
when accessing physical data storage containing Critical Software or Critical Data. (T-1) 
Verification activities should prove physical data storage access protocols execute error 
detecting and correcting actions against the data.
6.3.3.  The software developer shall protect Critical Software or Critical Data transported on 
rewritable physical data storage using methods capable of detecting tampering when outside 
of the control of the weapon system. (T-1) Verification activities should prove the rewritable 
physical data storage format uses encryption, digital signatures, or complex hashes to protect 
the data.
Chunk: 6.4.  Write Once Read Many Media.  Software developers can use Write Once Read Many 
media to store and transport Critical Software and Critical Data between weapon systems or within 
a weapon system with the following requirements: 
6.4.1.  The software developer shall use International Organization of Standardization (ISO) 
9660:1988/Amendment 2:2020, Volume and file structure of CD-ROM for information 
interchange protocols or equivalent protocols that provide single-session, one-write operations 
for storing Critical Software and Critical Data to Write Once Read Many media. (T-1) 
Verification activities should prove the format of the data on Write Once Read Many media 
complies with ISO 9660:1988/Amendment 2:2020 or equivalent protocol and the recording 
technique is finalized single-session on fresh media.
Chunk: 6.4.  Write Once Read Many Media.  Software developers can use Write Once Read Many 
media to store and transport Critical Software and Critical Data between weapon systems or within 
a weapon system with the following requirements: 
6.4.2.  The software developer shall use only single session recording techniques on fresh 
media for storing Critical Software and Critical Data to Write Once Read Many media. (T-1) 
Verification activities should prove the format of the data on Write Once Read Many media 
complies with ISO 9660:1988/Amendment 2:2020 or equivalent protocol and the recording 
technique is finalized single-session on fresh media.
Chunk: 6.4.  Write Once Read Many Media.  Software developers can use Write Once Read Many 
media to store and transport Critical Software and Critical Data between weapon systems or within 
a weapon system with the following requirements: 
6.4.3.  The software developer shall finalize the recording session for storing Critical Software 
and Critical Data to Write Once Read Many media to prevent changes to the media after 
storage. (T-1) Verification activities should prove the format of the data on Write Once Read 
Many media complies with ISO 9660:1988/Amendment 2:2020 or equivalent protocol and the 
recording technique is finalized single-session on fresh media.
Chunk: 6.4.  Write Once Read Many Media.  Software developers can use Write Once Read Many 
media to store and transport Critical Software and Critical Data between weapon systems or within 
a weapon system with the following requirements: 
6.4.4.  The software developer shall verify Write Once Read Many media by performing a 
comparison between the original data and the stored data using software different from what 
the software developer used to write to the media. (T-1) Verification activities should prove 
that the master disk and the copy are functionally identical via bit-for-bit comparison. The 
comparison should include all data on the media, using software that is different from the 
software the software developer used to create the media.
Chunk: 6.4.  Write Once Read Many Media.  Software developers can use Write Once Read Many 
media to store and transport Critical Software and Critical Data between weapon systems or within 
a weapon system with the following requirements: 
6.4.5.  The software shall use only high-level file access mechanisms that preclude direct 
access to the data for reading or storing Critical Software and Critical Data from or to Write 
Once Read Many media. (T-1) Verification activities should prove that the software only uses 
high-level file access for reading or storing Critical Software and Critical Data. In general, 
software should only access files on Write Once Read Many media through the operating 
system file input and output interfaces to avoid malicious covert channel attacks. 
Chunk: 8.2.7.  The software developer shall design the software in a hierarchical manner as defined in 
the following subparagraphs. (T-1) Verification activities should prove via the software and 
software design documentation that the software follows a hierarchical design. 
8.2.7.1.  The software developer has broken down the software by functionality. 
8.2.7.2.  The software developer has thoroughly defined interactions between components 
and has limited those interactions to specific functions using data hiding techniques.
Chunk: 8.2.8.  The software developer shall design the software such that the lowest-level software 
components that are directly responsible for Critical Signal initiation or propagation are single-
purpose components for initiating or propagating the Critical Signal. (T-1) Verification 
activities should prove that the lowest-level software components that are directly responsible 
for Critical Signal initiation or propagation are single-purpose.
Chunk: 8.4.  Self-Modifying Code.  The software developer shall design the software to not have the 
ability to modify its own instructions or the instructions of any other application. (T-1) Verification 
activities should prove that the certified configuration is unable to modify its own instructions or 
the instructions of other applications. A recommended method of partially meeting this 
requirement is using memory protections as paragraphs 9.3 and 10.3 provide.
Chunk: 8.5.1.  The software developer shall design the software to execute only after the operational 
software system loads and verifies all program instructions, programming files, and 
initialization files. (T-1) Verification activities should prove that software only executes after 
all loading and verification are complete.
Chunk: 8.5.2.  The software developer shall design the software to communicate results of the program 
load verification to the system operators or the crew. (T-1) Verification activities should prove 
that software communicates the results of the program load verification described in 
paragraph 8.5.1 to the system operator or the crew, or to external systems with the intent of 
communicating the results to the system operator or the crew.
Chunk: 8.5.3.  The system shall assume programs have not correctly loaded until receiving an 
affirmative load status. (T-1) Verification activities should prove that the system treats failure 
as the default load status.
Chunk: 8.5.4.  The software shall perform volatile memory initialization prior to the execution of the 
main application. (T-1) Verification activities should prove that software performs volatile 
memory initialization by writing all zeros or a known pattern into memory prior to the 
execution of the main application.
Chunk: 8.5.5.  The software shall load all non-volatile memory with executable code, data, or a non-
use pattern that the weapon system detects and processes safely upon execution. (T-1) 
Verification activities should prove that software loads all non-volatile memory with known 
data; non-use patterns cause the processor to respond in a known manner. 
Chunk: 8.6.1.  The system shall provide at a minimum hardware double bit error detection and single 
bit correction on all volatile memory. (T-1) Verification activities should prove that hardware 
provides double bit error detection and single bit correction on all volatile memory.
Chunk: 8.6.2.  For memory protection that is software-enabled, the software shall enable at a minimum 
double bit error detection and single bit correction on all volatile memory. (T-1) Verification 
activities should prove that software enables at a minimum double bit error detection and single 
bit correction when not automatically enabled by hardware.
Chunk: 8.8.1.  For weapon systems that use certain types of non-volatile memory such as flash memory 
to store data from one execution cycle to the next, memory wear-leveling is a concern. Wear-
leveling causes changes in the addressing of data in the flash memory device, which degrades 
confidence in the verification activities.
8.8.2.  The system shall not implement wear-leveling to limit the effect of erasures to non-
volatile memory with memory wear limits when that non-volatile memory is used to store data 
that can directly affect the operations of software that can affect Critical Signals. (T-1) If the 
software responsible for translating virtual addressing to physical addressing is fully testable 
by executing tests against every possible virtual and physical address combination, then this 
requirement is met. The software developer should segregate the translation software; for 
example, the translation software could be placed in a dedicated Programmable Logic Device. 
Verification activities should prove that the system does not implement wear-leveling on 
memory with wear limitations, or that the software developer tests the wear-leveling algorithm 
for every possible virtual and physical address combination. The software developer can 
simulate the algorithm testing if the algorithm software is directly accessible by the software 
developer. This requirement does not apply if the wear-leveled non-volatile memory is only 
used for initialization sequences before the start of operations that can affect Critical Signals.
Chunk: 8.9.1.  The software shall initialize to a known safe state and verify full functionality of 
hardware involved in the generation or propagation of Critical Signals. (T-1) Verification 
activities should prove that software properly initializes hardware involved in the generation 
or propagation of Critical Signals. If the software uses an RTOS, then the RTOS should always 
initialize to a known safe state.
Chunk: 8.9.2.  The system shall ensure a controlled transition to a safe state in the event of 
unanticipated power loss or system failure. (T-1) Verification activities should prove that the 
system performs a controlled transition to a safe state in the event of unanticipated power loss 
or system failure.
Chunk: 8.9.3.  The software shall set all non-volatile devices involved in the generation or propagation 
of Critical Signals to a safe state upon controlled shutdown or program termination. (T-1) 
Verification activities should prove that the software properly shuts down non-volatile devices 
including physical devices such as relays or non-volatile memory devices involved in the 
generation or propagation of Critical Signals during a controlled shutdown or program 
termination.
Chunk: 8.9.4.  The system shall incorporate hardware watchdog timers on each nuclear critical 
processor to assist in detecting failures in the software. (T-1) Verification activities should 
prove that each nuclear critical processor has a dedicated hardware watchdog timer.
Chunk: 8.9.5.  The software shall respond to a hardware watchdog notification or warning by 
performing a controlled shutdown and reverting to a safe state. (T-1) Verification activities 
should prove that software responds appropriately to a hardware watchdog notification or 
warning.
Chunk: 8.10.1.  The focus of the weapon system fault detection and response is the potential of faults 
to impact Critical Signals. Faults may occur due to hardware failures, software defects, or 
malicious attacks. The software should be able to detect all faults regardless of the cause of the 
fault.
Chunk: 8.10.2.  The software developer shall identify Critical Signal-impacting fault conditions and 
define maximum acceptable Critical Signal transient and recoverable fault rates. (T-1) 
Analysis of the design documentation should prove that they contain all appropriate fault 
conditions. The Verification Organization needs to analyze the list for completeness.
Chunk: 8.10.3.  The software shall verify all hardware device integrity and operational states that can 
impact Critical Signals or prevent the propagation of the Safing Command. (T-1) Verification 
activities should prove that the software verifies the integrity and proper state of hardware 
devices. Tests should include, at a minimum, verification of major types of failures, with at 
least one failure type per hardware device tested.
Chunk: 8.10.4.  The software shall verify functionality of volatile memory prior to use. (T-1) 
Verification activities should prove that the software verifies volatile memory prior to use.
Chunk: 8.10.5.  The software shall detect and appropriately respond to Critical Signal-impacting 
hardware and software faults during all stages of execution; including startup, operation, and 
shutdown; within the lesser of (1) the maximum operationally acceptable time and prior to the 
time limit; and (2) the time to any associated irreversible adverse system event. (T-1) 
Verification activities should prove that the software detects hardware and software faults 
during all stages of execution within an acceptable time and responds to those faults within an 
acceptable time.
Chunk: 8.10.6.  The software shall report the events defined in the following subparagraphs to the 
operator within the lesser of (1) the maximum operationally acceptable time and prior to the 
time limit, and (2) the time to any associated irreversible adverse system event. (T-1) 
Verification activities should prove that the software reports the listed events and automated 
actions to the operator within an acceptable time. 
8.10.6.1.  Hardware and software faults that could adversely affect the initiation or 
propagation of Critical Signals. 
8.10.6.2.  Hardware and software faults that could adversely affect the ability of the 
weapon system to accurately recognize its own state. 
8.10.6.3.  The status of any actions the software takes to address the fault.
Chunk: 8.10.7.  The software shall revert to a known safe state and stop all Critical Signal propagation 
when the software detects an unrecoverable Critical Signal-impacting fault. (T-1) Verification 
activities should prove that the software reverts to a known safe state and stops all Critical 
Signal propagation within an acceptable time when the software detects a Critical Signal-
impacting fault.
Chunk: 8.10.8.  The software shall revert to a known safe state and stop all Critical Signal propagation 
when the software detects unauthorized modifications to the executable code during execution. 
(T-1) Verification activities should prove that the software reverts to a known safe state and 
stops all Critical Signal propagation when the software detects an issue with the integrity of 
the executable code; the software should also immediately set the global state of the software 
to a safe state to prevent or interrupt the transmission of Critical Signals. The detection method 
can be an automated software process or a hardware mechanism such as processor-based 
runtime integrity checking.
Chunk: 8.10.9.  The software that verifies the integrity and operational state of hardware devices 
through methods that verify interfaces between devices shall verify those interfaces to all layers 
of the interface protocol. (T-1) See paragraph 8.10.3 Verification activities should prove that 
the software verifies the interfaces to all protocol levels, not solely the physical electrical 
values or network information present in the interface.
Chunk: 8.11.1.  All Critical Signals originate with human intent, the action of an authorized human to 
initiate a critical function. The system should avoid requiring positive human actions to prevent 
the initiation or propagation of Critical Signals. The following would be a design paradigm to 
avoid: a system that automatically prearms a weapon unless the operator activates a switch.
Chunk: 8.11.2.  The software shall withdraw or cancel previously issued Critical Signals upon 
withdrawal of human intent and revert to the state the system was in prior to issuance of the 
Critical Signal, until the final irreversible action of Launch or Release, within the lesser of (1) 
the maximum operationally acceptable time and prior to the time limit, and (2) the time to any 
associated irreversible adverse system event. (T-1) Verification activities should prove that the 
software cancels Critical Signals after withdrawal of human intent through a single human 
action within an acceptable time.
Chunk: 8.11.3.  The system shall require only a single human action for withdrawal of human intent. 
(T-1) Verification activities should prove that the software recognizes a single human action 
as withdrawal of human intent and an unrecoverable failure as implied human intent and 
cancels Critical Signals.
Chunk: 8.11.4.  The system shall identify improper or incorrect operator entries and notify the operator 
of the improper entries within the lesser of (1) the maximum operationally acceptable time and 
prior to the time limit, and (2) the time to any associated irreversible adverse system event. (T-
1) Verification activities should prove that the software identifies improper operator entries 
and notifies the operator within an acceptable time.
Chunk: 8.11.5.  The software shall issue the final irreversible Critical Signal representing the activation 
of the associated final irreversible critical function of Launch or Release, only after receiving 
two distinct human affirmations that the human operator cannot inadvertently actuate. (T-1) 
Verification activities should prove that the software requires two distinct human affirmations 
that the human operator cannot inadvertently actuate before issuing the final irreversible 
Critical Signal representing the activation of the associated final irreversible critical function. 
The software may automate the final irreversible Critical Signal if the software has previously 
satisfied the human intent requirements in the employment sequence. The following sequences 
of separate actions meet this requirement: Prearming and Authorization; or Prearming and 
Release or Launch.
Chunk: 8.11.6.  The software shall originate or propagate Critical Signals only if the software 
recognizes all applicable preconditions. (T-1) Verification activities should prove that the 
software only originates or propagates Critical Signals if and only if the software recognizes 
all applicable preconditions. Refer to paragraph 8.12.3.
Chunk: 8.11.7.  The software source code or configuration files shall not contain the pattern that 
represents the Prearm unique signal within the software in a directly usable form. (T-1) 
Verification activities should prove that the software does not contain the pattern that 
represents the Prearm unique signal.
Chunk: 8.11.8.  The software shall not assemble the Prearm unique signal except as a result of operator 
action. (T-1) Verification activities should prove that the software assembles the Prearm 
unique signal only after operator action.
Chunk: 8.11.9.  The software shall not repair or attempt to repair Prearm unique signals or 
Authorization codes, except as part of a mathematically deterministic error-correction 
operation. (T-1) Verification activities should prove that the software does not attempt to repair 
Prearm unique signals or Authorization codes. Mathematically deterministic operations, such 
as Reed-Solomon encoding, memory error detection and correction, and other forward error 
correction algorithms, are not applicable to this requirement.
Chunk: 8.11.10.  The software shall delete Prearm unique signals or Authorization codes after 
transmission by writing a value that has no relationship to the original signal or code to all 
memory locations that contain the signals or codes. (T-1) Verification activities should prove 
that the software writes over Prearm unique signals and Authorization codes with a number 
that has all bits set to “1,” for example.
Chunk: 8.11.11.  The software shall invalidate the navigation information and inhibit the arming of the 
weapon if a real-time processing error, software reset, or other software failure has 
compromised the integrity of the target location or weapon location. (T-1) Verification 
activities should prove that software errors or resets cannot adversely affect the integrity of 
Navigation Validation due to loss or corruption of data.
Chunk: 8.11.12.  The software shall always attempt to send a Safing Command to the weapon and 
weapon system after the software recognizes that the weapon should be made safe due to a 
failure or the removal of human intent. (T-1) Verification activities should prove that the 
software attempts to send a Safing Command to the weapon and weapon system even if the 
weapon will be powered down automatically or manually. For this requirement, failures 
include but are not limited to failures of any component that provides human intent such as a 
component that reads switches or button presses or failures of any component that propagates 
Safing Commands throughout the weapon system. 
DAFMAN91-119  11 MARCH 2020 
41
Chunk: 8.11.13.  The software shall prioritize the propagation of Safing Commands above all other 
message types. (T-1) Verification activities should prove that the software prioritizes Safing 
Commands in queues, task priorities, and other constructs to propagate the Safing Commands 
as quickly as possible.
Chunk: 8.12.2.  The software shall use data patterns for Critical Signal representations internal to the 
software, command words internal to the software, and state representations internal to the 
software that meet the restrictions in the following subparagraphs. (T-1) Verification activities 
should prove that Critical Signal format, command words, and state representations in the 
software all meet the restrictions preventing inadvertent recognition of an incorrect value. For 
commands that the software passes through multiple software components, designers should 
consider values that the software mathematically manipulates within each function. This 
verifies that all functions have processed the command words correctly: 
8.12.2.1.  The data patterns are a complex sequence of bit “ones” and “zeros.” 
8.12.2.2.  The data patterns are not all “ones” or all “zeros.” 
8.12.2.3.  The data patterns maximize the Hamming distance from other valid values of the 
data type in question, Critical Signal, command word, or state, while avoiding values that 
are bitwise complementary. 
8.12.2.4.  The data patterns are unique, preventing the software from accidentally using a 
value of one data type in a different data type. 
8.12.2.5.  The data patterns are such that errors containing two-bit flips do not result in a 
valid value of that data type. It is acceptable to use multiple sets of patterns in order to meet 
this restriction, effectively creating much larger base types. For example, two 32-bit 
variables may be set and read together as one variable, even if the variables are not 
contiguous in memory.
Chunk: 8.12.3.  The software subroutines that are directly responsible for Critical Signal initiation or 
propagation shall initiate or propagate the Critical Signal only after verifying states and 
preconditions to ensure that the software executes the low-level components only with proper 
authorization. (T-1) Verification activities should prove that the software subroutines - 
functions or procedures, or other types of subroutines - that are directly responsible for Critical 
Signal initiation or propagation verify states and preconditions prior to initiating or propagating 
Critical Signals.
Chunk: 8.12.4.  The software that represents the lowest-level software components that are directly 
responsible for Critical Signal initiation or propagation shall notify the operator if state and 
precondition verification fail within the lesser of (1) the maximum operationally acceptable 
time and prior to the time limit; and (2) the time to any associated irreversible adverse system 
event. (T-1) Verification activities should prove that the software components that are directly 
responsible for Critical Signal initiation or propagation notify the operator within an acceptable 
time when state and precondition verification fails. 
Chunk: 8.13.1.  The weapon system should protect Critical Signals as they travel throughout a weapon 
system. The weapon system design should protect Critical Signals in manners similar to those 
described in Chapter 3, but also have additional protective mechanisms that ensure that 
malicious actors have not intentionally altered the Critical Signals.
Chunk: 8.13.2.  The software shall use data patterns for Critical Signal representations throughout the 
weapon system and in transit between weapon system components that meet the restrictions in 
the following subparagraphs. (T-1) Verification activities should prove that the Critical Signal 
data patterns throughout the weapon system and in transit between weapon system components 
meet the restrictions preventing inadvertent recognition of an incorrect value. 
8.13.2.1.  The data patterns are complex sequence of bit “ones” and “zeros.” 
8.13.2.2.  The data patterns are not all “ones” or all “zeros.” 
8.13.2.3.  The data patterns maximize the Hamming distance from other valid values while 
avoiding values that are bitwise complementary. 
8.13.2.4.  The data patterns are such that errors containing two-bit flips do not result in a 
valid value.
Chunk: 8.13.3.  The software shall use message formats for Critical Signals throughout the weapon 
system and in transit between weapon system components such that the Critical Signal 
messages meet the restrictions in the following subparagraphs. (T-1) Verification activities 
should prove that Critical Signal message formats throughout the weapon system and in transit 
between weapon system components meet the restrictions preventing inadvertent or malicious 
corruption. 
8.13.3.1.  Critical Signal messages use message protection mechanisms to prevent 
inadvertent or intentional corruption of the Critical Signal. 
8.13.3.2.  A malicious actor cannot spoof Critical Signal messages, particularly on shared 
bus architectures or over-the-air broadcasts.
Chunk: 8.13.4.  The software shall use message formats, message-protection mechanisms, and 
identification methods that ensure the receiver authenticates the sender as a valid sender for 
transmission of Critical Signals via over-the-air broadcasts or transmission over media outside 
of immediate control of the weapon system. (T-1) Verification activities should prove that the 
weapon system protects Critical Signals for transmission of over-the-air broadcasts or 
transmission over media outside of immediate control of the weapon system.
Chunk: 8.13.5.  The software shall validate message content down to the bit level for all aspects of any 
data provided to the software on interfaces with non-USAF-certified items. (T-1) This includes 
NSA-certified hardware, DOE-qualified hardware, and any other items included in the weapon 
system that could affect Critical Signals, such as Inertial Measurement Units, flight control 
systems, or environmental sensors. Verification activities should prove that the software uses 
validation methods on the message content of interfaces with non-USAF hardware that meet 
the following guidelines: 
8.13.5.1.  Software validates the data down to the bit level. 
8.13.5.2.  Software checks each data type in the message for valid values. 
8.13.5.3.  If certain portions of the message interpret other portions of the message, then 
the software should sequentially validate the message by meaning; if one part of the 
message provides information on how to interpret another part of the message, then the 
software should process the message by sections in order to validate fully each section.
Chunk: 8.13.6.  The software shall validate the message content of any Critical Signals the software 
has received from any location down to the bit level. (T-1) Verification activities should prove 
that the software uses validation methods on the message content of any Critical Signals that 
meet the following guidelines: 
8.13.6.1.  Software validates the data down to the bit level. 
8.13.6.2.  Software checks each data type in the message for valid values. 
8.13.6.3.  If certain portions of the message interpret other portions of the message, then 
the software should sequentially validate the message by meaning; if one part of the 
message provides information on how to interpret another part of the message, then the 
software should process the message by sections in order to validate fully each section.
Chunk: 8.13.7.  The software shall delete any data representing Critical Signals other than the Safing 
Command that the software has received from outside of the software immediately after receipt 
and validation of the Critical Signal by writing a value that has no relationship to the original 
Critical Signal data to all memory locations that contain the Critical Signal data. (T-1) 
Verification activities should prove that the software deletes Critical Signal representations 
immediately after receipt and validation.
Chunk: 8.13.8.  The software shall delete any data representing Critical Signals other than the Safing 
Command that the software has transmitted outside of the software immediately after 
transmission of the Critical Signal by writing a value that has no relationship to the original 
Critical Signal data to all memory locations that contain the Critical Signal data. (T-1) 
Verification activities should prove that the software deletes Critical Signal representations 
immediately after transmission.
Chunk: 8.14.1.  The software should use secure methods to validate that the software applications are 
the approved, trusted applications.
Chunk: 8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
Chunk: 8.15.1.  The software shall not contain unused code. (T-1) Verification activities should prove 
that the software does not contain unused code with the following clarifications: 
8.15.1.1.  The software developer should still test source code that is obsolete due to 
changes to the weapon system. The software developer should remove obsolete code that 
is untestable. 
8.15.1.2.  The software developer should document in the Nuclear Surety Evaluation 
source code that is untestable due to the nature of the code, error handling in the code or 
low-level source code the software developer designed for very specific scenarios. 
8.15.1.3.  The preferred unused code analysis is statement coverage testing. This form of 
dynamic analysis is a conclusive method for proving that software does not contain unused 
code. 
8.15.1.4.  Fuzzing is also a recommended tool to ensure coverage-testing focuses only on 
necessary sections of code. For Complex Programmable Logic Devices and Application 
Specific Integrated Circuits, the software or build process disables functions in intellectual 
property sections at interface boundaries. 
8.15.1.5.  The software developer may use synthesis optimization to eliminate functions 
that the software cannot reach if this option is available. This requirement applies to spare 
gates and unused gate array cells only so far as to require the software developer to wire 
these inactive in layout.
Chunk: 8.15.2.  The software shall not contain global variables. (T-1) Verification activities should 
prove that the software does not contain global variables.
Chunk: 8.15.3.  The software shall not contain uninitialized variables. (T-1) Verification activities 
should prove that the software does not contain uninitialized variables.
Chunk: 8.15.4.  The software shall bound the depth of recursive functions such that recursion does not 
exhaust available resources. (T-1) Verification activities should prove that the software does 
not contain unbounded recursion – the repeated application of a function with no built-in 
logical limit – or recursion that could exhaust resources such as stack memory.
Chunk: 8.15.5.  The software shall not execute memory allocation functions after application 
initialization. (T-1) Verification activities should prove that the software only executes 
memory allocation functions before or during application initialization.
Chunk: 8.16.1.  The software shall implement strict scheduling algorithms and task prioritization to 
avoid task lockup scenarios and meet response time requirements on the target processor under 
worst-case conditions if the software is responsible for cancelling a Critical Signal after the 
withdrawal of human intent or if the software is responsible for issuing a Safing Command. 
(T-1) Verification activities should prove that the software includes scheduling algorithms, 
task priorities and other such information that may be necessary to prove that the software 
should meet such deadlines under all system load and interrupt processing conditions. The 
software developer may do this by analyzing rate monotonic analyses performed against the 
software.
Chunk: 8.16.2.  The software shall not use any paradigm or abstraction that contributes to non-
deterministic execution sequences if the software is responsible for cancelling a Critical Signal 
after the withdrawal of human intent or if the software is responsible for issuing a Safing 
Command. (T-1) Verification activities should prove that the software does not use any 
paradigm or abstraction that contributes to non-deterministic execution sequences or non-static 
memory allocation such as distributed resource scheduling, dynamic memory allocation, 
runtime allocation of processors or cores, non-reentrant subroutines, or any algorithm that uses 
random execution.
Chunk: 8.16.3.  The software shall implement mechanisms to prevent or resolve deadlock conditions 
if the software is responsible for cancelling a Critical Signal after the withdrawal of human 
intent or if the software is responsible for issuing a Safing Command. (T-1) Verification 
activities should prove that the software implements mechanisms such as priority inversion or 
task-assigned resources to prevent or resolve deadlock conditions.
Chunk: 9.2.  Programming Languages.  Software developers should design and develop software to be 
reproducible during compilation and during execution. Just-in-time compilation is not acceptable 
due to the variability of the executable from one execution to the next. To that end, Ada, C, and 
C++ are the only recommended programming languages for development of new software. 
Assembly language is acceptable if AFSEC/SEWN approves it. Examples of assembly language 
usage that AFSEC/SEWN would approve include low-level interfaces, boot code, and time-critical 
software. AFSEC/SEWN discourages the use of dynamic linking in general, but particularly if the 
execution location of the object code changes during different executions. See paragraph 9.2.5.
Chunk: 9.2.1.  Software developers should use the standard library functions a development 
environment or compiler provides, rather than locally developed library functions. If there is a 
compelling reason to change or add to the standard library functions, the software developer 
may locally develop library functions. Compelling reasons for developing local library 
functions include defects or type incompatibility in a standard library function.
Chunk: 9.2.2.  The software developer shall use an internationally recognized, standardized, and 
mature programming language. (T-1) Verification activities should prove that the software 
uses only appropriate programming language(s), specifically Ada, C, or C++.
Chunk: 9.2.3.  The software developer shall not use assembly language in software applications 
without prior AFSEC/SEWN approval. (T-1) Verification activities should prove that the 
software does not use assembly language. If the software does use assembly language, the 
software developer should provide evidence to ensure that AFSEC/SEWN has approved the 
use of assembly language. As noted in section paragraph 9.5.5, assembly language used in 
RTOSs is exempt from this justification requirement.
Chunk: 9.2.4.  The software developer shall use the original programming language when modifying 
software unless the software developer has obtained prior AFSEC/SEWN approval. (T-1) 
Verification activities should prove that the versions of languages and development 
environment tools are consistent across software versions.
Chunk: 9.2.5.  The software developer shall develop software that always executes using the same 
static memory map during each execution, power cycle, software reset, or processor reset. (T-
1) Verification activities should prove that the software does not use just-in-time compilation 
or run-time dependent configurations and always executes from the same memory map during 
each execution.
Chunk: 9.2.6.  The software developer shall use industry-standard software coding guidelines and 
conventions to reduce safety concerns, such as Motor Industry Software Reliability 
Association standards for C and C++ revision current at time of implementation or the 
Ravenscar profile for Ada. (T-1) Verification activities should prove that the software meets 
an industry-standard AFSEC/SEWN approved software coding guideline and convention. The 
software developer should justify variances from the standard. The software developer should 
use an automated tool to verify that the developed software meets the industry-standard 
software development guidelines and conventions.
Chunk: 9.3.  Memory Characteristics of Application Software.  At a minimum, processors should have 
a Memory Management Unit to assign access permissions to specific areas of hardware, but 
AFSEC/SEWN prefers keyed access control.
Chunk: 9.3.1.  The software shall enable memory protection through a memory management unit at a 
minimum to the access permission levels found in the following subparagraphs. (T-1) 
Verification activities should prove that the software appropriately enables memory protection 
through a memory management unit. The software developer may use other mechanisms 
besides a memory management unit, but the software developer should prove the effectiveness 
of the mechanisms. 
9.3.1.1.  Object code. Read only, Executable. 
9.3.1.2.  Variables. Read/Write, Non-Executable. 
9.3.1.3.  Constants. Read only, Non-Executable.
Chunk: 9.4.2.  The software shall not use any instruction intended to cause the processor to pause or 
stop operations if the software is responsible for cancelling a Critical Signal after the 
withdrawal of human intent or if the software is responsible for issuing a Safing Command. 
(T-1) Verification activities should prove that the software does not use any instruction 
intended to cause the processor to pause or stop operations. Allowable exceptions to this 
requirement include wait states associated with memory access time, exceptions that the 
software cannot handle such as multiple bit errors in volatile memory, or anti-tamper 
protections.
Chunk: 9.4.3.  The software shall handle all exceptions that would cause the processor to stop 
operations if the software is responsible for cancelling a Critical Signal after the withdrawal of 
human intent or if the software is responsible for issuing a Safing Command. (T-1) Verification 
activities should prove that the software handles all exceptions that would cause the processor 
to pause or stop operations. 
Chunk: 9.4.4.  If the software is responsible for cancelling a Critical Signal after the withdrawal of 
human intent or if the software is responsible for issuing a Safing Command, then the software 
should not disable interrupts for longer than necessary to process time-critical sections.
Chunk: 9.5.1.  An RTOS is a software application that provides operating system services and 
specifically provides real-time tasking to minimize the latency of input-to-output functions. If 
the software uses an RTOS, this section enforces specific requirements to protect the system 
from malicious actors. These requirements apply if a failure of the software can lead to the 
failure to deactivate a Critical Signal after the withdrawal of human intent or the software is 
responsible for providing a Safing Command.
Chunk: 9.5.2.  A Run-Time System is a software component that provides execution services. In many 
cases, Run-Time Systems are specific to a particular programming language. In general, the C 
Run-Time System is fairly small, the C++ Run-Time System is bigger due to the need to 
instantiate classes and other object-oriented constructs, and the Ada Run-Time System is fairly 
large because it instantiates object-oriented constructs and maintains a tasking environment.
Chunk: 9.5.9.  The software shall transition into a known safe state, cancel Critical Signals, and require 
a restart, automatic or manual, after experiencing either a stack overflow or a failure in real-
time operations if the software is responsible for cancelling a Critical Signal after the 
withdrawal of human intent or if the software is responsible for issuing a Safing Command. 
(T-1) Verification activities should prove that the software transitions into a known safe state, 
cancels Critical Signals, and requires a restart upon stack overflows or real-time operation 
failures.
Chunk: 9.5.10.  The software shall report failure to maintain real-time operations or stack overflow to 
the operator if the software is responsible for cancelling a Critical Signal after the withdrawal 
of human intent or if the software is responsible for issuing a Safing Command. (T-1) 
Verification activities should prove that the software reports real-time operations failures to 
the operator.
Chunk: 9.5.11.  The software developer shall disable all configuration options in the RTOS that are 
not necessary for software operation if the software uses an RTOS. (T-1) Verification activities 
should prove that the RTOS kernel or main application has all unnecessary configuration 
options removed. For example, the software developer should remove network stack 
capabilities when the software does not need a network stack.