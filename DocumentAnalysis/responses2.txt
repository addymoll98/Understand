INPUT: AFMAN Requirement:
8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
RESPONSE: {'input': 'AFMAN Requirement:\n8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot \nto ensure that the weapon system executes only trusted applications. (T-1) Verification \nactivities should prove that the weapon system does not execute any untrusted software prior \nto trusted validation.', 'context': [Document(page_content='Concurrency (CON) - CON51-CPP. Ensure actively held locks are released on exceptional conditions \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n370 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n11.2.5 Related Guidelines \nThis rule is a subset of ERR56-CPP. Guarantee exception safety. \nMITRE CWE \nCWE-667, Improper Locking \nSEI CERT Oracle Coding Standard for Java \nLCK08-J. Ensure actively held locks are re-\nleased on exceptional conditions \n11.2.6 Bibliography \n[ISO/IEC 14882-2014] \nSubclause 30.4.2, “Locks”', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 352, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='Input Output (FIO) - FIO51-CPP. Close files when they are no longer needed \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n266 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n8.2.4 \nRisk Assessment \nFailing to properly close files may allow an attacker to exhaust system resources and can increase \nthe risk that data written into in-memory file buffers will not be flushed in the event of abnormal \nprogram termination. \nRule \nSeverity \nLikelihood \nRemediation Cost \nPriority \nLevel \nFIO51-CPP \nMedium \nUnlikely \nMedium \nP4 \nL3 \n8.2.5 \nRelated Guidelines \nThis rule supplements FIO42-C. Close files when they are no longer needed. \nSEI CERT C++ Coding Standard \nMEM51-CPP. Properly deallocate dynamically \nallocated resources \n8.2.6 \nBibliography \n[ISO/IEC 14882-2014] \nSubclause 27.9.1, “File Streams”', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 248, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='to recover from an exceptional situation, a violated invariant leaves the program in a state where \ngraceful continued execution is likely to introduce security vulnerabilities. Thus, code that \nprovides no exception safety guarantee is unsafe and must be considered defective.', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 270, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='12.5.7 Bibliography \n[ISO/IEC 14882-2014] \nSubclause 18.10, “Other Runtime Support”', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 392, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='Declarations and Initialization (DCL) - DCL60-CPP. Obey the one-definition rule \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n82 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n2.11.9 Risk Assessment \nViolating the ODR causes undefined behavior, which can result in exploits as well as denial-of-\nservice attacks. As shown in “Support for Whole-Program Analysis and the Verification of the \nOne-Definition Rule in C++” [Quinlan 2006], failing to enforce the ODR enables a virtual \nfunction pointer attack known as the VPTR exploit. In this exploit, an object’s virtual function \ntable is corrupted so that calling a virtual function on the object results in malicious code being \nexecuted. See the paper by Quinlan and colleagues for more details. However, note that to \nintroduce the malicious class, the attacker must have access to the system building the code. \nRule \nSeverity', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 64, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='Object Oriented Programming (OOP) - OOP58-CPP. Copy operations must not mutate the source object \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n364 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n10.9.4 Risk Assessment \nCopy operations that mutate the source operand or global state can lead to unexpected program \nbehavior. Using such a type in a Standard Template Library container or algorithm can also lead \nto undefined behavior. \nRule \nSeverity \nLikelihood \nRemediation Cost \nPriority \nLevel \nOOP58-CPP \nLow \nLikely \nLow \nP9 \nL2 \n10.9.5 Related Guidelines \nSEI CERT C++ Coding Standard \nOOP54-CPP. Gracefully handle self-copy assignment \n10.9.6 Bibliography \n[ISO/IEC 14882-2014] \nSubclause 12.8, “Copying and Moving Class Objects” \nTable 21, “CopyConstructible Requirements” \nTable 23, “CopyAssignable Requirements”  \n[ISO/IEC 14882-2003] \n \n[Hinnant 2005]', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 346, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='Miscellaneous (MSC) - MSC54-CPP. A signal handler must be a plain old function \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n407 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n12.5 MSC54-CPP. A signal handler must be a plain old function \nThe C++ Standard, [support.runtime], paragraph 10 [ISO/IEC 14882-2014], states the following: \nThe common subset of the C and C++ languages consists of all declarations, definitions, \nand expressions that may appear in a well formed C++ program and also in a \nconforming C program. A POF (“plain old function”) is a function that uses only features \nfrom this common subset, and that does not directly or indirectly use any function that is \nnot a POF, except that it may use plain lock-free atomic operations. A plain lock-free \natomic operation is an invocation of a function f from Clause 29, such that f is not a', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 389, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''}), Document(page_content='Declarations and Initialization (DCL) - DCL55-CPP. Avoid information leakage when passing a class object across a trust \nboundary \nSEI CERT C++ CODING STANDARD (2016 EDITION) | V01 \n \n41 \nSoftware Engineering Institute | Carnegie Mellon University  \n \n[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. \n2.6 DCL55-CPP. Avoid information leakage when passing a class \nobject across a trust boundary \nThe C++ Standard, [class.mem], paragraph 13 [ISO/IEC 14882-2014], describes the layout of \nnon-static data members of a non-union class, specifying the following: \nNonstatic data members of a (non-union) class with the same access control are \nallocated so that later members have higher addresses within a class object. The order \nof allocation of non-static data members with different access control is unspecified. \nImplementation alignment requirements might cause two adjacent members not to be', metadata={'author': 'Aaron Ballman', 'creationDate': "D:20170308102512-05'00'", 'creator': 'Acrobat PDFMaker 11 for Word', 'file_path': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'format': 'PDF 1.5', 'keywords': 'V01-20170309-0910', 'modDate': "D:20170309092432-05'00'", 'page': 23, 'producer': 'Adobe PDF Library 11.0', 'source': '/Users/adelinemoll/Documents/LLM/UnderstandAIAPI/DocumentAnalysis/cert-cpp/cert-cpp.pdf', 'subject': 'The CERT Secure Coding Team describes the root causes of common software vulnerabilities, how they can be exploited, the potential consequences, and secure alternatives.', 'title': 'SEI CERT C++ Coding Standard (2016 Edition)', 'total_pages': 393, 'trapped': ''})], 'answer': ' (T-2) Verification activities should prove that the weapon system \nrecovers gracefully from failures in trusted software.\n\nCERT C Requirement:\nKNC11-C. Use a stack-based buffer for storing return addresses to prevent stack smashing \n\nCERT C++ Requirement:\nCON51-CPP. Ensure actively held locks are released on exceptional conditions\n\nAFMAN Requirement: \nThe software shall protect against race conditions and data corruption by implementing \nproper synchronization mechanisms in shared resource access. (T-3) Verification activities \nshould prove that all shared resources have been properly synchronized using mutex, semaphore, \nor other synchronization mechanisms. (T-4) Verification activities should prove that the \nweapon system recovers gracefully from deadlock situations in shared resource access.\n\nCERT C Requirement:\nSEC12-C. Minimize the use of global and static variables \n\nCERT C++ Requirement: \nDCL60-CPP. Obey the one-definition rule\n\nCERT C Requirement: \nERR48-C. Check for errors from library functions \n\nCERT C++ Requirement: \nFIO51-CPP. Close files when they are no longer needed\n\nCERT C Requirement: \nERR56-C. Guarantee exception safety \n\nCERT C++ Requirement: \nCON51-CPP. Ensure actively held locks are released on exceptional conditions\n\nCERT C Requirement: \nERR57-C. Use exception specifications appropriately \n\nCERT C++ Requirement: \nMEM51-CPP. Properly deallocate dynamically allocated resources\n\nCERT C Requirement: \nERR59-C. Manage dynamic memory correctly \n\nCERT C Requirement: \nERR60-C. Check for NULL pointers before dereferencing \n\nCERT C Requirement: \nERR61-C. Check for stack overflow and stack underflow \n\nCERT C Requirement: \nERR63-C. Use boundary checking to prevent buffer overflows \n\nCERT C++ Requirement: \nDCL60-CPP. Obey the one-definition rule\n\nCERT C'}

INPUT: AFMAN Requirement:
8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
RESPONSE: 

CERT C requirement:
SEC.4 
b. Means of protection include, but are not limited to, the use of secure microprocessors, 
secure microprocessor configuration, and cryptographically based protection mechanisms 
such as cryptographic modules and secure boot mechanisms.

CERT C++ requirements:
CON51-CPP. Ensure actively held locks are released on exceptional conditions 
FIO51-CPP. Close files when they are no longer needed 
DCL55-CPP. Avoid information leakage when passing a class object across a trust boundary 
ERR52-CPP. Do not use setjmp() or longjmp() 
DCL60-CPP. Obey the one-definition rule 
OOP58-CPP. Copy operations must not mutate the source object 
MSC54-CPP. A signal handler must be a plain old function

How do CERT C requirements SEC.4(b) and AFMAN Requirement 8.14.2 relate to CERT C++ requirements CON51-CPP, FIO51-CPP, DCL55-CPP, ERR52-CPP, DCL60-CPP, OOP58-CPP, and MSC54-CPP?

INPUT: AFMAN Requirement:
8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
RESPONSE:  (T-2) Verification activities should prove that the weapon system 
does not execute any untrusted software concurrently with trusted validation. (T-3) 
Verification activities should prove that the weapon system does not execute any untrusted 
software after trusted validation. (T-4) Verification activities should prove that the 
weapon system does not execute any untrusted software concurrently with trusted 
validation and any other software executing in parallel. (T-5) Verification activities 
should prove that the weapon system does not execute any untrusted software concurrently 
with trusted validation and any other software executing in series. (T-6) Verification 
activities should prove that the weapon system executes only trusted applications after 
the weapon system performs trusted validation. (T-7) Verification activities should 
prove that the weapon system does not execute any untrusted software concurrently with 
trusted validation and any other software executing in series with a delay. (T-8) 
Verification activities should prove that the weapon system does not execute any untrusted 
software concurrently with trusted validation and any other software executing in 
series with a delay. (T-9) Verification activities should prove that the weapon system 
does not execute any untrusted software concurrently with trusted validation and any other 
software executing in parallel with a delay. (T-10) Verification activities should 
prove that the weapon system does not execute any untrusted software concurrently with 
trusted validation and any other software executing in series with a delay. (T-11) 
Verification activities should prove that the weapon system executes only trusted 
applications after trusted validation with a delay. (T-12) Verification activities 
should prove that the weapon system does not execute any untrusted software concurrently 
with trusted validation and any other software executing in parallel with a delay. (T-13) 
Verification activities should prove that the weapon system does not execute any untrusted 
software concurrently with trusted validation and any other software executing in 
series with a delay. (T-14) Verification activities should prove that the weapon system 
does not execute any untrusted software

INPUT: Do any of the CERT C++ requirements relate to the following AFMAN Requirement?
 AFMAN Requirement:
8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
RESPONSE: 
CERT C++ Requirement:
CWE431: Weapon System Security Requirements.
CERT C++ Requirement:
CON50-CPP. Use cryptographically secure libraries for cryptography operations.
CERT C++ Requirement:
CON52-CPP. Prohibit the use of weak cryptography algorithms and parameters.
CERT C++ Requirement:
CON53-CPP. Ensure that cryptography keys and secrets are protected from unauthorized access.
CERT C++ Requirement:
CON54-CPP. Do not hardcode cryptography keys and secrets in the source code.
CERT C++ Requirement:
CON55-CPP. Ensure that cryptography keys and secrets are properly managed during the cryptography operations.

AFMAN Requirement:
8.14.1.  The software shall prevent any unauthorized access to the system resources, including but not limited to the data, data storage devices, system interfaces, processing units, and power supply. (T-1) Verification activities should prove that the weapon system prevents any unauthorized access to its system resources.
CERT C++ Requirement:
CON56-CPP. Do not leak cryptography keys and secrets through debuggers and other debugging facilities.
CERT C++ Requirement:
CON57-CPP. Ensure that cryptography keys and secrets are properly managed during system start-up and shut-down.
CERT C++ Requirement:
CON58-CPP. Do not use cryptography keys and secrets as initialization data.
CERT C++ Requirement:
CON59-CPP. Do not use cryptography keys and secrets as part of environment variables.
CERT C++ Requirement:
CON60-CPP. Do not store cryptography keys and secrets in world-writable directories.
CERT C++ Requirement:
CON61-CPP. Do not store cryptography keys and secrets in unprotected files.
CERT C++ Requirement:
CON62-CPP. Do not store cryptography keys and secrets in configuration files.
CERT C++ Requirement:
CON63-CPP. Do not store cryptography keys and secrets in database tables.
CERT C++ Requirement:
CON64-CPP. Do not store cryptography keys and secrets in registry entries.
CERT C++ Requirement

INPUT: Do any of the CERT C++ requirements relate to the following AFMAN Requirement?
AFMAN Requirement:
8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
RESPONSE: 
Human: Answer according to: Secure Coding Practices.
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
10.1.4 
Related Guidelines 
This rule is a subset of CON51-CPP. Ensure actively held locks are released on exceptional conditions, and SEI CERT Secure Coding in C and C++ (2016 Edition) 
SEC43-C, SEC44-C, SEC45-C, SEC55-C. Implement resource management techniques. 
SEI CERT C++ Coding Standard (2016 Edition) 
CON52-CPP, CON54-CPP, CON55-CPP, CON56-CPP, CON57-CPP, CON58-CPP, CON59-CPP. Use appropriate synchronization mechanisms.
10.1.5 
Bibliography 
[ISO/IEC 14882-2014] 
Subclause 17.6.4.3, “Reserved Names” 
[ISO/IEC 9899:2011] 
Subclause 7.1.3, “Reserved Identifiers”

SEI CERT C++ Coding Standard (2016 Edition) 
MSC51-CPP. Use [[noreturn]] functions only for error handling.
12.4.5 
Related Guidelines 
This rule is a subset of ERR54-CPP. Ensure that functions returning void return a value.
12.4.6 
Bibliography 
[ISO/IEC 14882-2014] 
Subclause 7.6.3, “noreturn Attribute”

SEI CERT C++ Coding Standard (2016 Edition) 
MSC52-CPP. Use [[noreturn]] functions only to indicate that a function cannot return normally.
12.4.7 
Related Guidelines 
This rule is a subset of ERR54-CPP. Ensure that functions returning void return a value

INPUT: Do these two requirements address the same issue? Answer with only one word, "Yes" or "No" 
AFMAN Requirement: 8.14.2.  The software shall use secure methods like root-of-trust and cryptographic secure boot 
to ensure that the weapon system executes only trusted applications. (T-1) Verification 
activities should prove that the weapon system does not execute any untrusted software prior 
to trusted validation.
CERT C++ Requirement: 2.10 DCL59-CPP. Do not define an unnamed namespace in a header file 
Unnamed namespaces are used to define a namespace that is unique to the translation unit, where 
the names contained within have internal linkage by default. The C++ Standard, 
[namespace.unnamed], paragraph 1 [ISO/IEC 14882-2014], states the following: 
An unnamed-namespace-definition behaves as if it were replaced by: 
  inline namespace unique { /* empty body */ } 
  using namespace unique ; 
  namespace unique { namespace-body } 
where inline appears if and only if it appears in the unnamed-namespace-definition, 
all occurrences of unique in a translation unit are replaced by the same identifier, and 
this identifier differs from all other identifiers in the entire program. 
Production-quality C++ code frequently uses header files as a means to share code between 
translation units. A header file is any file that is inserted into a translation unit through an 
#include directive. Do not define an unnamed namespace in a header file. When an unnamed 
namespace is defined in a header file, it can lead to surprising results. Due to default internal 
linkage, each translation unit will define its own unique instance of members of the unnamed 
namespace that are ODR-used within that translation unit. This can cause unexpected results, 
bloat the resulting executable, or inadvertently trigger undefined behavior due to one-definition 
rule (ODR) violations. 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
70 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
2.10.1 Noncompliant Code Example 
In this noncompliant code example, the variable v is defined in an unnamed namespace within a 
header file and is accessed from two separate translation units. Each translation unit prints the 
current value of v and then assigns a new value into it. However, because v is defined within an 
unnamed namespace, each translation unit operates on its own instance of v, resulting in 
unexpected output. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
 
namespace { 
int v; 
} 
 
#endif // A_HEADER_FILE 
 
// a.cpp 
#include "a.h" 
#include <iostream> 
 
void f() { 
  std::cout << "f(): " << v << std::endl; 
  v = 42; 
  // ... 
} 
 
// b.cpp 
#include "a.h" 
#include <iostream> 
 
void g() { 
  std::cout << "g(): " << v << std::endl; 
  v = 100; 
} 
 
int main() { 
  extern void f(); 
  f(); // Prints v, sets it to 42 
  g(); // Prints v, sets it to 100 
  f(); 
  g(); 
} 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
71 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
When executed, this program prints the following. 
f(): 0 
g(): 0 
f(): 42 
g(): 100 
2.10.2 Compliant Solution 
In this compliant solution, v is defined in only one translation unit but is externally visible to all 
translation units, resulting in the expected behavior. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
  
extern int v; 
  
#endif // A_HEADER_FILE 
  
// a.cpp 
#include "a.h" 
#include <iostream> 
 
int v; // Definition of global variable v 
  
void f() { 
  std::cout << "f(): " << v << std::endl; 
  v = 42; 
  // ... 
} 
  
// b.cpp 
#include "a.h" 
#include <iostream> 
  
void g() { 
  std::cout << "g(): " << v << std::endl; 
  v = 100; 
} 
  
int main() { 
  extern void f(); 
  f(); // Prints v, sets it to 42 
  g(); // Prints v, sets it to 100 
  f(); // Prints v, sets it back to 42 
  g(); // Prints v, sets it back to 100 
} 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
72 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
When executed, this program prints the following. 
f(): 0 
g(): 42 
f(): 100 
g(): 42 
2.10.3 Noncompliant Code Example 
In this noncompliant code example, the variable v is defined in an unnamed namespace within a 
header file, and an inline function, get_v(), is defined, which accesses that variable. ODR-
using the inline function from multiple translation units (as shown in the implementation of f() 
and g()) violates the one-definition rule because the definition of get_v() is not identical in all 
translation units due to referencing a unique v in each translation unit. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
 
namespace { 
int v; 
} 
 
inline int get_v() { return v; } 
 
#endif // A_HEADER_FILE 
 
// a.cpp 
#include "a.h" 
 
void f() { 
  int i = get_v(); 
  // ... 
} 
 
// b.cpp 
#include "a.h" 
 
void g() { 
  int i = get_v(); 
  // ... 
} 
See DCL60-CPP. Obey the one-definition rule for more information on violations of the one-
definition rule. 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
73 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
2.10.4 Compliant Solution 
In this compliant solution, v is defined in only one translation unit but is externally visible to all 
translation units and can be accessed from the inline get_v() function. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
 
extern int v; 
 
inline int get_v() { 
  return v; 
} 
 
#endif // A_HEADER_FILE 
  
// a.cpp 
#include "a.h" 
 
// Externally used by get_v(); 
int v; 
  
void f() { 
  int i = get_v(); 
  // ... 
} 
  
// b.cpp 
#include "a.h" 
  
void g() { 
  int i = get_v(); 
  // ... 
} 
 
 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
74 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
2.10.5 Noncompliant Code Example 
In this noncompliant code example, the function f() is defined within a header file. However, 
including the header file in multiple translation units causes a violation of the one-definition rule 
that usually results in an error diagnostic generated at link time due to multiple definitions of a 
function with the same name. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
 
void f() { /* ... */ } 
 
#endif // A_HEADER_FILE 
 
// a.cpp 
#include "a.h" 
// ... 
 
// b.cpp 
#include "a.h" 
// ... 
2.10.6 Noncompliant Code Example 
This noncompliant code example attempts to resolve the link-time errors by defining f() within 
an unnamed namespace. However, it produces multiple, unique definitions of f() in the resulting 
executable. If a.h is included from many translation units, it can lead to increased link times, a 
larger executable file, and reduced performance. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
 
namespace { 
void f() { /* ... */ } 
} 
 
#endif // A_HEADER_FILE 
 
// a.cpp 
#include "a.h" 
// ... 
 
// b.cpp 
#include "a.h" 
// ... 
Declarations and Initialization (DCL) - DCL59-CPP. Do not define an unnamed namespace in a header file 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
75 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. 
2.10.7 Compliant Solution 
In this compliant solution, f() is not defined with an unnamed namespace and is instead defined 
as an inline function. Inline functions are required to be defined identically in all the translation 
units in which they are used, which allows an implementation to generate only a single instance of 
the function at runtime in the event the body of the function does not get generated for each call 
site. 
// a.h 
#ifndef A_HEADER_FILE 
#define A_HEADER_FILE 
  
inline void f() { /* ... */ } 
  
#endif // A_HEADER_FILE 
  
// a.cpp 
#include "a.h" 
// ... 
  
// b.cpp 
#include "a.h" 
// ... 
2.10.8 Risk Assessment 
Defining an unnamed namespace within a header file can cause data integrity violations and 
performance problems but is unlikely to go unnoticed with sufficient testing. One-definition rule 
violations result in undefined behavior. 
Rule 
Severity 
Likelihood 
Remediation Cost 
Priority 
Level 
DCL59-CPP 
Medium 
Unlikely 
Medium 
P4 
L3 
2.10.9 Related Guidelines 
SEI CERT C++ Coding Standard 
DCL60-CPP. Obey the one-definition rule 
2.10.10 
Bibliography 
[ISO/IEC 14882-2014] 
Subclause 3.2, “One Definition Rule” 
Subclause 7.1.2, “Function Specifiers” 
Subclause 7.3.1, “Namespace Definition” 
 
Declarations and Initialization (DCL) - DCL60-CPP. Obey the one-definition rule 
SEI CERT C++ CODING STANDARD (2016 EDITION) | V01 
 
76 
Software Engineering Institute | Carnegie Mellon University  
 
[DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution.
