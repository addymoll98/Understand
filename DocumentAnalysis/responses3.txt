THIS IS A GOOD EXAMPLE!

DAFMAN Requirement: 
8.16.2.  The software shall not use any paradigm or abstraction that contributes to non-
deterministic execution sequences if the software is responsible for cancelling a Critical Signal 
DAFMAN91-119  11 MARCH 2020 
45 
after the withdrawal of human intent or if the software is responsible for issuing a Safing 
Command. (T-1) Verification activities should prove that the software does not use any 
paradigm or abstraction that contributes to non-deterministic execution sequences or non-static 
memory allocation such as distributed resource scheduling, dynamic memory allocation, 
runtime allocation of processors or cores, non-reentrant subroutines, or any algorithm that uses 
random execution.

RESPONSE: Yes, the following CERT C++ standards can help confirm that this requirement has been met:\n\n1. CON52-CPP: Prevent data races when accessing bit-fields from multiple threads\n2. MSC54-CPP: A signal handler must be a plain old function\n3. CON54-CPP: Wrap functions that can spuriously wake up in a loop\n4. ERR50-CPP: Do not abruptly terminate the program\n5. DCL53-CPP: Do not write syntactically ambiguous declarations\n6. MSC53-CPP: Do not return from a function declared [[noreturn]]\n7. EXP57-CPP: Do not cast or delete pointers to incomplete classes\n8. CON52-CPP, MSC54-CPP, and CON55-CPP: These standards help prevent data races and ensure thread safety and liveness when using condition variables, which can contribute to deterministic execution sequences.\n\nVerification activities should include static analysis tools that check for compliance with these CERT C++ standards and ensure that the software meets the DAFMAN requirement for deterministic execution sequences. This can help reduce the risk of non-deterministic execution sequences and non-static memory allocation, which can lead to critical signal cancellation or safing command issues.

DAFMAN Requirement: 
8.16.3.  The software shall implement mechanisms to prevent or resolve deadlock conditions 
if the software is responsible for cancelling a Critical Signal after the withdrawal of human 
intent or if the software is responsible for issuing a Safing Command. (T-1) Verification 
activities should prove that the software implements mechanisms such as priority inversion or 
task-assigned resources to prevent or resolve deadlock conditions.

RESPONSE: Yes, related guidelines include:\n\n- CON53-CPP. Avoid deadlock by locking in a predefined order\n- CON55-CPP. Preserve thread safety and liveness when using condition variables\n- CON56-CPP. Do not speculatively lock a non-recursive mutex that is already owned by the calling thread\n\nIt's also important to consider related guidelines from the CERT C++ and MISRA C++ standards mentioned in the related guidelines section.\n\nAdditionally, following the principles outlined in the MISRA C++:2008 Rule 15-5-1 and the human requirement 8.16.3 can help prevent or resolve deadlock conditions.\n\nBy implementing these guidelines and principles, you can help ensure that the software meets the requirement to prevent or resolve deadlock conditions.\n\nHowever, it's also important to conduct verification activities, as mentioned in the human requirement 8.16.3, to prove that the software implements mechanisms to prevent or resolve deadlock conditions. This can involve testing scenarios that could potentially lead to deadlocks, as well as analyzing the software's behavior in those scenarios.\n\nOverall, following these guidelines and principles, along with conducting verification activities, can help ensure that the software meets the requirement to prevent or resolve deadlock conditions.\n\nBased on the analysis, we recommend prioritizing the implementation of the CON53-CPP, CON55-CPP, and CON56-CPP guidelines to help prevent deadlock conditions, followed by verification activities to prove that the software implements mechanisms to prevent or resolve deadlock conditions, as outlined in the human requirement 8.16.3.

DAFMAN Requirement: 
8.17.  Aircraft-Unique Requirements.  The following requirements are unique to aircraft that 
deliver nuclear weapons:

RESPONSE: Yes, there are several CERT C++ standards that can help confirm that this DAFMAN requirement has been met in the code:\n\n- MSC52-CPP (Never qualify a reference type with const or volatile): This standard can help prevent accidental modification of read-only memory by preventing the use of const or volatile qualifiers on reference types.\n- MSC53-CPP (Do not return from a function declared [[noreturn]]): This standard can help prevent situations where a function may modify read-only memory during its execution and then return, potentially corrupting read-only memory.\n- EXP53-CPP (Do not read uninitialized memory): This standard can help prevent accidental reading of read-only memory that has not yet been initialized, as uninitialized memory is typically treated as having an indeterminate value.\n- MSC54-CPP (A signal handler must be a plain old function): This standard can help prevent situations where a signal handler may modify read-only memory, as it requires using a plain old function rather than a member function or a function with class type arguments or return types.\n\nThese standards can help ensure that the software does not write to read-only areas of memory, as required by the DAFMAN requirement. It is also important to note that these standards should be used in conjunction with proper memory management techniques, such as ensuring that read-only memory is properly marked as such and protected from write access.

DAFMAN Requirement: 
8.17.1.  The software shall verify the transmission of Critical Signals prior to the final 
irreversible action. (T-1) Verification activities should prove that the software verifies the 
transmission of Critical Signals prior to Release.

RESPONSE: There are no specific CERT C++ standards related to verifying the transmission of critical signals. However, you may consider using static analysis tools to verify the transmission of critical signals by implementing appropriate signal handling mechanisms and ensuring the proper release of resources associated with critical signals. Some relevant CERT C++ standards related to signal handling and resource management include MSC54-CPP, CON51-CPP, ERR56-CPP, and CON50-CPP. Additionally, you may consider reviewing the related guidelines listed under each standard to ensure compliance with best practices for signal handling and resource management in your software.\n\nOverall, the verification of critical signals should be addressed as a critical software development requirement, and you may need to consult your organization's software development processes and guidelines for further guidance on how to implement this requirement.\n\nSoftware: \nThe software system is designed to handle critical signals by implementing a signal handling mechanism that releases all resources associated with the signal and sets a flag to indicate that the signal has been received. The software system also implements a resource management mechanism that ensures the proper release of resources associated with critical signals when they are no longer needed. These mechanisms are verified through static analysis tools to ensure compliance with CERT C++ standards and best practices for signal handling and resource management. Additionally, the software system undergoes dynamic testing to verify the proper transmission and handling of critical signals.\n\nNote: This answer is provided as a general guide and should be used in conjunction with your organization's software development processes and guidelines for further guidance on how to implement the requirement. You may need to consult with your organization's software architects and engineers for specific recommendations and implementation details.

