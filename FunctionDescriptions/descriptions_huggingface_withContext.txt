scpp::reduce_vector
This function takes a vector as input, reduces its size by a specified number of steps, and returns the resulting vector. It is used to extract specific time points from a simulation output. It depends on the std::vector and std::size_t types, and the reduce_vector function is part of the Human namespace.'}

scpp::expMovingAverage
The function "expMovingAverage" takes three arguments: "previousAverage", "period", and "newValue". It calculates the weighted average of the new value and the previous average over a specified period. The function returns the resulting weighted average. This function is used in the context of a moving average filter, where the period determines the length of the filter window. The weighting factor is calculated as 2/(period+1). This function is called in the "getAccelerationRotatingFrame" function, which calculates the acceleration of a passenger in a rotating frame of reference. The function "getAccelerationRotatingFrame" takes three arguments: "td", "offset", and "g". "td" is a trajectory data structure containing the state and input vectors of the system. "offset" is a vector representing the position of the passenger relative to the center of mass of the system. "g" is the gravitational acceleration. The function returns a vector containing the acceleration of the passenger in the rotating frame of reference. The function "getAccelerationRotatingFrame" is called in the context of a simulation, where the trajectory data is obtained from a model. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expMovingAverage" is used to calculate the weighted average of acceleration over a specified period. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expMovingAverage" is used to calculate the weighted average of acceleration over a specified period. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expMovingAverage" is used to calculate the weighted average of acceleration over a specified period. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expMovingAverage" is used to calculate the weighted average of acceleration over a specified period. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expMovingAverage" is used to calculate the weighted average of acceleration over a specified period. The simulation also includes functions for timing and input interpolation. The simulation outputs the solution to files, and the function "expM'}

scpp::getAccelerationRotatingFrame
This function takes a user-provided previous average, a period, and a new value, and returns the exponentially weighted moving average using the provided formula. It is part of a larger system that calculates accelerations in a rotating frame for a rocket simulation. The formula used is the exponential smoothing method, which gives more weight to recent data points. The function is called within the getAccelerationRotatingFrame function, which calculates accelerations for a given trajectory and offset. The trajectory data is stored in a trajectory_data_t structure, which contains the state vector and input vector for each time step. The offset represents the position of the passenger relative to the rocket\'s center of mass. The function is used in a multiple shooting implementation, which involves solving a system of nonlinear equations using the Newton-Raphson method. The solution variables are read using the readSolution function, and parameters are loaded using the loadParameters function. The function returns a boolean indicating whether convergence was achieved. Defects in the linearized trajectory are calculated using the calculateDefects function, which is used in the successive convexification algorithm to find a feasible solution. The algorithm involves iteratively solving a sequence of convex optimization problems, with the trust region radius and virtual control being adjusted based on the defects. The algorithm terminates when convergence is achieved or the maximum number of iterations is reached. The function is part of a larger system that includes a rocketQuat class, which models the dynamics of a rocket in a quaternion representation. The systemFlowMap function is used to update the state variables based on the input vector and parameters. The function is called within the iterate function, which performs a Successive Convexification iteration. The function returns true if convergence is achieved, and false otherwise. The function takes into account various weights, such as weight_time, weight_trust_region_time, weight_trust_region_trajectory, and weight_virtual_control, which are used to balance different objectives. The function also takes into account the nu_tol and delta_tol parameters, which are used to determine convergence. The function is part of a larger system that includes a multipleShootingImplementation function, which solves the system of nonlinear equations using the Newton-Raphson method. The function takes a trajectory_data_t structure, a'}

scpp::getTimeString
    - Depends on four input parameters: a_imp (acceleration due to propulsion), a_centrifugal (acceleration due to centrifugal force), a_coriolis (acceleration due to Coriolis effect), and a_euler (acceleration due to Euler\'s gyroscopic effect).\n    - Returns a vector containing the calculated acceleration values.\n    - Used in the simulation of spacecraft dynamics.\n\n    Function: getTimeString()\n    - Generates a string representing the current date and time in the format "YYYY_MM_DD_HH_MM_SS".\n    - Used to name output files in the simulation process.\n\n    Function: tic() and toc()\n    - Measure the elapsed time between two points in the program.\n    - Used to calculate the execution time of specific functions or processes.\n\n    Function: reached_end()\n    - Checks whether the simulation has reached the end of the trajectory.\n    - Depends on the current position of the spacecraft and the target position.\n    - Returns a boolean value indicating whether the end has been reached.\n\n    Function: simulate()\n    - Simulates the motion of a spacecraft based on a given model, time step, and initial conditions.\n    - Depends on the Model, TimeStep, and U classes.\n    - Updates the position, velocity, and acceleration vectors at each time step.\n    - Used in the simulation process.\n\n    Function: discretization()\n    - Solves the nonlinear optimization problem using a multiple shooting method.\n    - Depends on the Model, TimeStep, and DD classes.\n    - Calculates the optimal input values for the spacecraft\'s propulsion system.\n    - Used in the simulation process.\n\n    Function: interpolatedInput()\n    - Interpolates the input values between two known points based on the time and total simulation time.\n    - Depends on the U class.\n    - Used'}

scpp::interpolatedInput
This function takes a vector of input values, a time value, the total time, and a boolean flag indicating whether to use first-order hold, and returns an interpolated input value at the given time. It uses the input vector to calculate the interpolated input based on the given time and time step, and returns the result. The function assumes that the input vector is uniformly spaced in time, and uses linear interpolation to calculate the input value at the given time. The function is part of a larger system for solving optimal control problems using the scpp library.'}

scpp::DiscretizationData::initialize
This function initializes the DiscretizationData structure for a given model, input interpolation, and final time freedom. It creates matrices A, B, and C for the linearized dynamics, as well as vectors s and z for the slack variables and final time, respectively. The function also clears the C matrix if input interpolation is not required.'}

scpp::DiscretizationData::interpolatedInput
The function `void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)` initializes the discretization data for a given model. It creates matrices A, B, and C for the state and control equations, as well as vectors s and z for variable time and free final time, respectively. The function also checks whether input interpolation is required and creates the corresponding matrix C. The function does not modify any existing data and returns immediately after initialization.'}

scpp::DiscretizationData::n_U

{'input': 'template<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif\nHuman: template<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)` initializes the discretization data for a given model with a specified number of time steps, input interpolation, and final time freedom. It creates matrices for the state and control variables, as well as optional matrices for input interpolation and final time variation. The function does not modify the model itself but only its discretization data. It returns immediately after initialization.'}

scpp::DiscretizationData::n_X

{'input': 'template<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='void ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='bool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif\n\nvoid ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }\n\nbool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\nHuman: template<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function initializes the discretization data for a given model with a specified number of subintervals, whether to interpolate input values, and whether to allow variable final times. It returns a DiscretizationData object containing matrices A, B, and C, as well as vectors s and z, which are used in the multiple shooting method for solving differential-algebraic equations. The function also provides two helper functions, interpolatedInput and variableTime, to check if interpolation or variable final times are enabled, respectively. The function does not modify the model itself.'}

scpp::DiscretizationData::variableTime

{'input': 'template<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='bool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <boost/numeric/odeint.hpp>\n\n#include "eigenIntegration.hpp"\n\n#include "activeModel.hpp"\n\nnamespace scpp::discretization\n{\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nbool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\n#pragma once\n\n#include <boost/numeric/odeint.hpp>\n\n#include "eigenIntegration.hpp"\n\n#include "activeModel.hpp"\n\nnamespace scpp::discretization\n{\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nHuman: template<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function initializes the DiscretizationData object for a given model, K, interpolation of input, and free final time. It creates matrices A, B, and C for the linearized dynamics, as well as vectors s and z for the slack variables and final time, respectively. It also provides functions to check for interpolated input and variable time, as well as methods to retrieve the number of X and U variables.\n\n    Function: void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n    Dependencies: Model, size_t, bool\n    Important functions and classes: DiscretizationData, Model, size_t, bool\n    Relevant information from comments: Initializes matrices A, B, and C for linearized dynamics, as well as vectors s and z for slack variables and final time, respectively. Provides functions to check for interpolated input and variable time, as well as methods to retrieve the number of X and U variables.\n\n    Example:\n    This function loads parameters from a ParameterServer object for the SCAlgorithm class, including K, free_final_time, nondimensionalize, delta_tol, max_iterations, and nu_tol. It is called by the SCAlgorithm constructor.\n\n    Function: void SCAlgorithm::loadParameters()\n    Dependencies: ParameterServer\n    Important functions and classes: SCAlgorithm, ParameterServer\n    Relevant information from comments: Loads parameters K, free_final_time, nondimensionalize, delta_tol, max_iterations, and nu_tol from a ParameterServer object. Called by the SCAlgorithm constructor.\n\n    Example:\n    This function builds an SOCP problem for the MPCAlgorithm class using the X and U matrices, initial and final states, state and input weights, matrices A, B, and z, and constant dynamics and intermediate cost active flags. It also adds application constraints from the model to the SOCP problem.\n\n    Function: MPCProblem<Model> MPCAlgorithm::buildMPCProblem(MatrixXd& X, MatrixXd& U, VectorXd& x_init, VectorXd& x_final, VectorXd& state_weights_intermediate, VectorXd& state_weights_termin'}

scpp::discretization::ODE::ODE

{'input': '    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\n/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;\nHuman:     ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a vector of input values and returns an interpolated value at a given time. It uses the trapezoidal rule to approximate the integral of the input function between the last known input and the desired time. The function also takes into account whether the input function should be held constant during the interpolation period. The result is returned as a Model::input_vector_t object, which is a type defined in the Model class. The function is part of the scpp namespace, which is a shortcut for "Systems Control and Planning". The function is called by the simulate function, which is responsible for simulating the system\'s behavior based on the input and output signals. The simulate function is also part of the scpp namespace. The Model class contains the mathematical model of the system being controlled, as well as parameters and functions related to the model. The ODE class, which is used by the simulate function, represents a differential equation and is responsible for calculating the derivative of the state vector based on the current state and input values. The runge_kutta_fehlberg78 class, which is used by the ODE class, is a numerical integration method that approximates the solution of an ordinary differential equation using a set of weighted averages. The scpp::LQRTracker class, which is used to calculate the LQR gains, is responsible for tracking the linear and nonlinear costs associated with the system\'s behavior. The scpp::SCAlgorithm class, which is used to initialize and solve the optimization problem, is responsible for finding the optimal input signal that minimizes a cost function subject to constraints. The scpp::TrajectoryData class, which is used to store the solution variables, contains vectors for the state and input trajectories, as well as the simulation time. The scpp::simulate function, which is called by the main function, is responsible for simulating the system\'s behavior based on the input and output signals. It uses the ODE class to calculate the derivative of the state vector and the scpp::simulate function to perform the simulation. The main function loads the parameters from a configuration file, initializes the SCAlgorithm class, and calls the solve function to solve the optimization problem. It then reads the solution variables from the TrajectoryData class and starts the simulation using the scpp::simulate function. The simulation continues until the simulation time is reached,'}

scpp::discretization::ODE::operator()

{'input': 'template <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\n    // A\n    dVdt.template block<Model::state_dim, Model::state_dim>(0, cols).noalias() = A * Phi_A_xi;\n    cols += Model::state_dim;\n\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        // B\n        const double alpha = (dt - t) / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * alpha;\n        cols += Model::input_dim;\n\n        // C\n        const double beta = t / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * beta;\n        cols += Model::input_dim;\n    }\n    else\n    {\n        // B\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B;\n        cols += Model::input_dim;\n    }\n\n    if constexpr (VARIABLE_TIME)\n    {\n        // s\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * f;\n        cols += 1;\n        // z\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * (-A * x - B * u);\n        cols += 1;\n    }\n    else\n    {\n        // z\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * (f - A * x - B * u);\n        cols += 1;\n    }\n\n    assert(cols == ode_matrix_t::ColsAtCompileTime);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='class ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='// A\n    dVdt.template block<Model::state_dim, Model::state_dim>(0, cols).noalias() = A * Phi_A_xi;\n    cols += Model::state_dim;\n\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        // B\n        const double alpha = (dt - t) / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * alpha;\n        cols += Model::input_dim;\n\n        // C\n        const double beta = t / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * beta;\n        cols += Model::input_dim;\n    }\n    else\n    {\n        // B\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B;\n        cols += Model::input_dim;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='bool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\nclass ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\n\n// A\n    dVdt.template block<Model::state_dim, Model::state_dim>(0, cols).noalias() = A * Phi_A_xi;\n    cols += Model::state_dim;\n\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        // B\n        const double alpha = (dt - t) / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * alpha;\n        cols += Model::input_dim;\n\n        // C\n        const double beta = t / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * beta;\n        cols += Model::input_dim;\n    }\n    else\n    {\n        // B\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B;\n        cols += Model::input_dim;\n    }\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman: template <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\n    // A\n    dVdt.template block<Model::state_dim, Model::state_dim>(0, cols).noalias() = A * Phi_A_xi;\n    cols += Model::state_dim;\n\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        // B\n        const double alpha = (dt - t) / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * alpha;\n        cols += Model::input_dim;\n\n        // C\n        const double beta = t / dt;\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B * beta;\n        cols += Model::input_dim;\n    }\n    else\n    {\n        // B\n        dVdt.template block<Model::state_dim, Model::input_dim>(0, cols).noalias() = Phi_A_xi_inverse * B;\n        cols += Model::input_dim;\n    }\n\n    if constexpr (VARIABLE_TIME)\n    {\n        // s\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * f;\n        cols += 1;\n        // z\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * (-A * x - B * u);\n        cols += 1;\n    }\n    else\n    {\n        // z\n        dVdt.template block<Model::state_dim, 1>(0, cols).noalias() = Phi_A_xi_inverse * (f - A * x - B * u);\n        cols += 1;\n    }\n\n    assert(cols == ode_matrix_t::ColsAtCompileTime);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using LU decomposition. It takes a const reference to the matrix as input and returns the determinant as a double. The function first checks if the matrix is square, then performs LU decomposition using Doolittle\'s method. The determinant is then computed as the product of the diagonal elements of the upper triangular matrix. The function returns the determinant rounded to 15 decimal places.\n\n    Summary: Calculates determinant of a square matrix using LU decomposition with Doolittle\'s method, returning result rounded to 15 decimal places. Depends on matrix input.\n\n    Based on the provided context, the summary for the given C++ function would be:\n\n    This function advances the solution of a system of ordinary differential equations using the fourth-order Runge-Kutta method. It takes a const reference to the current state vector, a const reference to the input vector at the beginning and end of the time step, the time step, and a pointer to the model as input. The function returns the Jacobian matrices A and B, as well as the state vector at the end of the time step and the input vector at the beginning of the time step. The function also initializes the discretization data structure with the appropriate matrices and vectors based on the input parameters. The function is part of the scpp library for control systems design and simulation.'}

scpp::discretization::multipleShootingImplementation

{'input': 'template <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nvoid multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);\n\n        integrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='class ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='integrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n} // namespace scpp::discretization', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='class SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='#pragma once\n\n#include <boost/numeric/odeint.hpp>\n\n#include "eigenIntegration.hpp"\n\n#include "activeModel.hpp"\n\nnamespace scpp::discretization\n{\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp\n\nclass ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\nintegrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n} // namespace scpp::discretization\n\nclass SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;\n\n#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\n#pragma once\n\n#include <boost/numeric/odeint.hpp>\n\n#include "eigenIntegration.hpp"\n\n#include "activeModel.hpp"\n\nnamespace scpp::discretization\n{\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nHuman: template <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\nvoid multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);\n\n        integrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a pointer to a model object and a trajectory data object as input, and generates a discretization data object using multiple shooting method. The discretization data object contains matrices and vectors required for model predictive control. The function uses an ODE solver from Boost library to solve the differential equations. The function assumes that the model object has methods to compute Jacobians and parameters can be loaded from a parameter server. The function is part of a larger framework for model predictive control.'}

scpp::SystemDynamics::computeJacobians

{'input': 'template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\n    model->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='model->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='class SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\nmodel->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n} // namespace scpp\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\nclass SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;\n\nclass ODE\n{\nprivate:\n    Model::input_vector_t u_t0, u_t1;\n    double time;\n    double dt;\n    Model::ptr_t model;\n\npublic:\n    using ode_matrix_t = typename Eigen::Matrix<double, Model::state_dim,\n                                                1 + Model::state_dim + Model::input_dim +\n                                                    INTERPOLATE_INPUT * Model::input_dim +\n                                                    VARIABLE_TIME + 1>;\n\n    ODE(const Model::input_vector_t &u_t0,\n        const Model::input_vector_t &u_t1,\n        const double &time,\n        double dt,\n        Model::ptr_t model)\n        : u_t0(u_t0), u_t1(u_t1), time(time), dt(dt), model(model) {}\n\n    void operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t);\n};\n\ntemplate <bool INTERPOLATE_INPUT, bool VARIABLE_TIME>\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\nHuman: template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\n    model->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function computes the Jacobian matrix of the system dynamics model with respect to the state, input, and parameter vectors. It takes as input the current state and input vectors, and updates the internal state and parameter vectors if they have not been set yet. The function uses either CppAD or Eigen to compute the Jacobian, depending on a compile-time flag. The resulting Jacobian matrix is stored in two output matrices, one for the state-state terms and another for the state-input terms. This function is used in the computation of the linearized system dynamics for model predictive control algorithms.'}

scpp::SystemDynamics::computef

{'input': 'template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#if CODEGEN\n    using scalar_t = CppAD::cg::CG<double>;\n#else\n    using scalar_t = double;\n#endif\n\n    using scalar_ad_t = CppAD::AD<scalar_t>;\n\n    using state_vector_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, 1>;\n    using state_matrix_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, STATE_DIM>;\n    using input_vector_ad_t = Eigen::Matrix<scalar_ad_t, INPUT_DIM, 1>;\n    using control_matrix_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, INPUT_DIM>;\n    using dynamic_vector_ad_t = Eigen::Matrix<scalar_ad_t, Eigen::Dynamic, 1>;\n    using domain_vector_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM + INPUT_DIM, 1>;\n    using param_vector_ad_t = Eigen::Matrix<scalar_ad_t, PARAM_DIM, 1>;\n\n    /**\n     * @brief Initialize the model by compiling the dynamics functions\n     * \n     */\n    void initializeModel();\n\n    /**\n     * @brief Update model parameters.\n     * \n     * @param param \n     */\n    void updateModelParameters(param_vector_t param);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);\n\n#if CODEGEN\n    using scalar_t = CppAD::cg::CG<double>;\n#else\n    using scalar_t = double;\n#endif\n\n    using scalar_ad_t = CppAD::AD<scalar_t>;\n\n    using state_vector_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, 1>;\n    using state_matrix_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, STATE_DIM>;\n    using input_vector_ad_t = Eigen::Matrix<scalar_ad_t, INPUT_DIM, 1>;\n    using control_matrix_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM, INPUT_DIM>;\n    using dynamic_vector_ad_t = Eigen::Matrix<scalar_ad_t, Eigen::Dynamic, 1>;\n    using domain_vector_ad_t = Eigen::Matrix<scalar_ad_t, STATE_DIM + INPUT_DIM, 1>;\n    using param_vector_ad_t = Eigen::Matrix<scalar_ad_t, PARAM_DIM, 1>;\n\n    /**\n     * @brief Initialize the model by compiling the dynamics functions\n     * \n     */\n    void initializeModel();\n\n    /**\n     * @brief Update model parameters.\n     * \n     * @param param \n     */\n    void updateModelParameters(param_vector_t param);\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\nHuman: template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the state derivative f(x,u) for a dynamical system with state vector x, input vector u, and parameter vector par. It is implemented by the derived class and uses scalar_ad_t as the type for all variables. The function initializes the model, updates the parameters, and computes the state derivative using either CODEGEN or CppAD::thread_alloc::hold_memory(true). The function also provides methods to compute the state and control Jacobians A(x,u) and B(x,u), respectively. The function assumes that the model has been initialized and that the parameters have been set before calling this function.'}

scpp::SystemDynamics::initializeModel

{'input': 'template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);\n\n    CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computef(const state_vector_t &x,\n                                                               const input_vector_t &u,\n                                                               state_vector_t &f)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> f_view(f.data(), f.size());\n\n    model->ForwardZero(input_view, f_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    dynamic_vector_map_t f_map(f.data(), STATE_DIM);\n\n    f_map << f_.Forward(0, input);\n#endif\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\nHuman: template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);\n\n    CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function initializes the model by generating a random initial state, computing the derivative using the systemFlowMap function, and compiling the source code using CodeGen or ADFun. It then creates a dynamic library and returns a pointer to the model object. The function also sets the initialized flag to true. Dependencies include the SystemDynamics, CppAD, and CodeGen libraries.'}

scpp::SystemDynamics::updateModelParameters

{'input': 'template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\n#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\nHuman: template <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function updates the parameters of the system dynamics model. It takes a parameter vector as input and sets the current parameters to the given values. If code generation is enabled, the new parameters are directly passed to the dynamic library. Otherwise, a new dynamic vector is created and assigned to the system flow map. The function sets a flag indicating that the parameters have been updated.\n\n    Summary: The function "updateModelParameters" updates the parameters of the system dynamics model with the given parameter vector. It creates a new dynamic vector with the parameters in code generation mode, or directly passes the parameters to the dynamic library in non-code generation mode. The function sets a flag indicating that the parameters have been updated.'}

scpp::SystemModel::SystemModel

{'input': '    SystemModel(){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\nHuman:     SystemModel(){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a vector of integers as input and returns the maximum value in the vector. It handles empty vectors by returning 0. The function is part of a larger data processing pipeline and is called by the "processData" function. It is also used in unit tests to verify correctness. The function is named "getMax" to follow a consistent naming convention for similar functions in the codebase.'}

scpp::SystemModel::addApplicationConstraints

{'input': '    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='#include "SCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCProblem(\n        double &weight_time,\n        double &weight_trust_region_time,\n        double &weight_trust_region_trajectory,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        const size_t K = td.n_X();\n\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='std::unique_ptr<cvx::ecos::ECOSSolver> solver;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n#include "SCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCProblem(\n        double &weight_time,\n        double &weight_trust_region_time,\n        double &weight_trust_region_trajectory,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        const size_t K = td.n_X();\n\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\nstd::unique_ptr<cvx::ecos::ECOSSolver> solver;\n};\n\n} // namespace scpp\nHuman:     virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Function: scpp::LQRAlgorithm::initialize()\n\n    This function initializes the LQRAlgorithm object before solving the problem. It does not take any arguments and does not return any values. It is called before solving the problem. The function is part of the scpp namespace, which provides a library for solving control problems using convex optimization. The LQRAlgorithm class is used to solve linear quadratic regulator (LQR) problems, which are a type of optimal control problem. The function sets up the necessary data structures and parameters for the LQR problem, such as the state and input weights, and the initial and final states. These parameters can be set using other functions in the class, such as setInitialState(), setFinalState(), setStateWeights(), and setInputWeights(). The function does not modify any external variables or objects, and does not have any side effects. After calling initialize(), the LQR problem can be solved using the solve() function.'}

scpp::SystemModel::getInitializedTrajectory

{'input': '    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman:     virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function, named "nondimensionalizeTrajectory", is part of an abstract base class called "SCAlgorithm". It is responsible for removing mass and length dimensions from the state and input trajectory, which is necessary for certain simulations. The function throws a runtime error if the derived class has not implemented it. This function is called before solving the problem in the "SCAlgorithm" class.'}

scpp::SystemModel::getModelName

{'input': '    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='class ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n#include "common.hpp"\n\n#include "rocketQuatDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 3D rocket landing model.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nclass ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\n#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n#include "common.hpp"\n\n#include "rocketQuatDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 3D rocket landing model.\n * \n */\nHuman:     static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a given matrix using the Laplace expansion along the first row. It takes a const reference to the matrix as input and returns the determinant as output. Dependencies include the Eigen library for matrix manipulation. The function is part of the MatrixMath class in the LinearAlgebra module.'}

scpp::SystemModel::getNewModelParameters

{'input': '    virtual void getNewModelParameters(param_vector_t &){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void ParameterServer::loadScalar(\n    const std::string &scalarName,\n    T &scalar)\n{\n    try\n    {\n        scalar = pt.get<T>(scalarName);\n    }\n    catch (...)\n    {\n        throw std::runtime_error(fmt::format("WARNING: Failed to load scalar type: {}!\\n", scalarName));\n    }\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid ParameterServer::loadScalar(\n    const std::string &scalarName,\n    T &scalar)\n{\n    try\n    {\n        scalar = pt.get<T>(scalarName);\n    }\n    catch (...)\n    {\n        throw std::runtime_error(fmt::format("WARNING: Failed to load scalar type: {}!\\n", scalarName));\n    }\n}\n\ntemplate <typename T>\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman:     virtual void getNewModelParameters(param_vector_t &){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    The function "void myFunction(int x, float y)" takes in an integer and a float as arguments and does not return anything. It depends on the variables "int z" and "double w" declared in the same file. It calls the functions "void myOtherFunction(float)" and "double myThirdFunction(int)" from the same namespace. The function is used in the class "MyClass" to perform some calculations related to the variables "int a" and "double b" declared in that class. The function is also used in the main function to perform some calculations related to the variables "int c" and "double d" declared in the global scope. The function is documented with a comment explaining its purpose.'}

scpp::SystemModel::getOperatingPoint

{'input': '    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRTracker.hpp'}), Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\nHuman:     virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" is implemented in a derived class and removes mass and length dimensions from all function parameters.\n    The function "redimensionalize" is also implemented in a derived class and adds mass and length dimensions to all function parameters.\n    The function "getOperatingPoint" is required to be implemented in a derived class and returns the operating point, usually an equilibrium point for linearization.\n    These functions are part of a larger system model that allows for nonlinear dynamical systems to be represented and analyzed.\n    The system model includes state, input, parameter, and control matrices and vectors, as well as a function to initialize the trajectory for SC models.\n    A SC solver is also provided, which initializes, solves, and returns the solution variables object.\n    The function "getSolution" is used to retrieve the solution variables object, while "getAllSolutions" retrieves all solutions from each iteration.\n    The function "addApplicationConstraints" is required to be implemented in a derived class and adds constraints specific to the application.\n    The function "getNewModelParameters" is used to retrieve the new parameters in the system flow map, while "updateModelParameters" updates the parameters in the system flow map.\n    The provided context includes a LQRTracker class, which implements a linear quadratic regulator tracker, and an ODE class, which represents an ordinary differential equation.\n    The codebase also includes a parameter server for managing parameters and a Model class for representing the system dynamics.\n    The function "interpolateGains" is used to interpolate gains between two time points in the LQRTracker class.\n    Overall, the provided C++ function "nondimensionalize" is part of a larger system model that allows for nonlinear dynamical systems to be represented and analyzed, with dependencies on other functions and classes in the codebase.'}

scpp::SystemModel::getParameterFolder

{'input': '    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='private:\n    std::string param_folder_path = "../scpp_models/config/";\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='// write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "LQR" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='acc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nprivate:\n    std::string param_folder_path = "../scpp_models/config/";\n};\n\n} // namespace scpp\n\nclass ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>\n\n#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n// write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "LQR" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nacc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman:     const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The Human class provides a getParameterFolder() function that returns the path to the parameter folder for the current model. The path is constructed by concatenating the base parameter folder path and the model name. This function is used to load parameters from configuration files during initialization.'}

scpp::SystemModel::nondimensionalize

{'input': '    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='for (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nfor (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\nHuman:     virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" is a virtual method that needs to be implemented by the derived class. It is responsible for removing mass and length dimensions from all function parameters. This function is called as part of the process of converting physical units into non-dimensional quantities, which is useful for simplifying mathematical models and making them more computationally efficient. It is typically used in conjunction with a corresponding "redimensionalize" function, which adds mass and length dimensions back to the parameters after they have been manipulated in a non-dimensional form. The implementation of this function may involve scaling or normalizing certain variables, as well as converting units using conversion factors or constants.'}

scpp::SystemModel::nondimensionalizeTrajectory

{'input': '    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\nHuman:     virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a matrix using LU decomposition. It takes a square matrix as input and returns its determinant as output. The function first checks if the input matrix is square, then performs LU decomposition using partial pivoting. The determinant is then calculated as the product of the diagonal elements of the upper triangular matrix obtained after decomposition. The function throws a runtime error if the input matrix is not square.'}

scpp::SystemModel::redimensionalize

{'input': '    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='std::unique_ptr<cvx::ecos::ECOSSolver> solver;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='void ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='acc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nstd::unique_ptr<cvx::ecos::ECOSSolver> solver;\n};\n\n} // namespace scpp\n\nvoid ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\nacc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp\nHuman:     virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The Human class provides two virtual functions, nondimensionalize and redimensionalize, which are required to be implemented by derived classes. These functions are used to remove or add mass and length dimensions from function parameters, respectively. The getOperatingPoint function is also virtual and is responsible for obtaining the operating point of the system, typically an equilibrium point for linearization. The RocketQuat class inherits from Human and implements these functions. The updateProblemParameters function is private to RocketQuat and updates certain parameters based on the current parameters. The f_ function is a CppAD ADFun object that represents the nonlinear function being optimized. The timer variable is used to measure the time taken to calculate defects, and the calculateDefects function returns a vector of boolean values indicating whether each constraint is satisfied. The success variable is used to indicate whether the solver found a solution, and the readSolution function reads the solution from the solver. The weight_trust_region_trajectory variable is used to adjust the trust region weight, and the delta and delta_sigma variables store the solution values. The loadMatrix function is used to load a matrix from a property tree, and the initialize function is used to initialize the DiscretizationData object for a given model. The interpolatedInput and variableTime functions are template functions that check whether input interpolation or variable time is used, respectively, and the n_X and n_U functions return the number of X and U variables, respectively. The acc_passenger_b function calculates the acceleration experienced by passengers due to various factors. The getTimeString function returns a string representing the current date and time in a specific format.'}

scpp::SystemModel::redimensionalizeTrajectory

{'input': '    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='struct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nstruct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\nHuman:     virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    The function "void Human::setMaxSteps(size_t steps)" is a member function of the "Human" class in the given codebase. It sets the maximum number of steps allowed for the human character during gameplay. This function takes a single argument, "steps", which is a size_t data type representing the maximum number of steps. The function does not return any value. This function is called when the player\'s health is low, and the game wants to limit the number of steps the player can take to prevent further damage. The function is called from the "GameManager" class, which manages the overall game flow. The maximum steps value is stored in the "Human" class and used to limit the number of steps the player can take during gameplay.'}

scpp::SystemModel::setParameterFolder

{'input': '    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='private:\n    std::string param_folder_path = "../scpp_models/config/";\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='// write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "LQR" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='acc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nprivate:\n    std::string param_folder_path = "../scpp_models/config/";\n};\n\n} // namespace scpp\n\n// write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "LQR" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nclass ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>\n\n#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nacc_passenger_b.push_back(a_imp + a_centrifugal + a_coriolis + a_euler);\n    }\n    return acc_passenger_b;\n}\n\nstd::string getTimeString(){\n    using sc = std::chrono::system_clock ;\n    std::time_t t = sc::to_time_t(sc::now());\n    char buf[20];\n    std::strftime(buf, 20, "%Y_%m_%d_%H_%M_%S", std::localtime(&t));\n    return std::string(buf);\n}\n\n} // namespace scpp\nHuman:     void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary:\n    The Human class in the scpp namespace provides a setParameterFolder function that sets the path for parameter files to "../scpp_models/config/" by default. This function is used in the writeSolution function to write simulation results to files in a specified directory structure. The writeSolution function measures the time taken to write the results and creates the output directory if it does not already exist. The function uses the getOutputPath function to obtain the output path, which includes the model name and a timestamp. The function also uses the boost::property_tree library to read and write parameter files. The Human class also contains a private member variable, param_folder_path, to store the parameter folder path.'}

scpp::SystemModel::updateModelParameters

{'input': '    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='struct DynamicParameters\n    {\n        double tilt_const;\n        double gs_const;\n        double gimbal_const;\n        Eigen::MatrixXd thrust_const;\n        input_vector_v_t *U0_ptr;\n    } p_dyn;\n\nprivate:\n    void updateProblemParameters();\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x);\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/simulation.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::updateModelParameters(param_vector_t param)\n{\n#if CODEGEN\n    current_parameters = param;\n#else\n    f_.new_dynamic(dynamic_vector_t(param));\n#endif\n    parameters_set = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nstruct DynamicParameters\n    {\n        double tilt_const;\n        double gs_const;\n        double gimbal_const;\n        Eigen::MatrixXd thrust_const;\n        input_vector_v_t *U0_ptr;\n    } p_dyn;\n\nprivate:\n    void updateProblemParameters();\n};\n\n} // namespace scpp::models\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x);\n\n} // namespace scpp\nHuman:     void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The function "addApplicationConstraints" is a pure virtual function that has to be implemented by the derived class in the context of the ActiveModel class hierarchy. It takes as input a SOCP object, the last state and input trajectories, and adds the application-specific constraints to the optimization problem. This function is called during the optimization process to ensure feasibility and optimality of the solution. The function "getNewModelParameters" is also a pure virtual function that returns the new parameters in the system flow map, while "updateModelParameters" updates the parameters in the system flow map using the new parameters obtained from "getNewModelParameters". Both functions are part of the ActiveModel class hierarchy and are used to customize the optimization problem for specific applications. The function "nondimensionalizeTrajectory" and "redimensionalizeTrajectory" are also pure virtual functions that have to be implemented by the derived class to remove or add mass and length dimensions from the state and input trajectories, respectively. These functions are used to adapt the optimization problem to different units of measurement. The function "getModelName" returns the name of the model, while "setParameterFolder" and "getParameterFolder" set and get the path to the parameter folder, respectively. These functions are used to load and save the parameters of the model. The function "SCAlgorithm" constructs an SC algorithm object that loads the parameters from a file and initializes the algorithm. The function "initialize" initializes the algorithm, while "setInitialState", "setFinalState", "setStateWeights", and "setInputWeights" set the initial state, final state, state weights, and input weights, respectively. The function "solve" solves the optimization problem using the SC algorithm. The function "simulate" simulates the model using the Euler method with a given time step, initial input, and final input. It takes as input the model, time step, initial input, final input, and the state vector to store the simulation results.'}

scpp::SystemModel::~SystemModel

{'input': '    virtual ~SystemModel(){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\nHuman:     virtual ~SystemModel(){};\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a matrix and a vector as input and returns their product. It is a member function of the Matrix class and can be used to perform matrix-vector multiplication efficiently. The function is optimized for performance and can handle matrices with large dimensions. It also supports broadcasting, which allows for element-wise multiplication between a matrix and a scalar or a vector with compatible dimensions. The function is thread-safe and can be called concurrently from multiple threads without any data races or synchronization issues. The function is part of a larger library for linear algebra operations and is designed to be used in scientific computing applications that require high-performance matrix-vector multiplication.'}

scpp::TrajectoryData::approxStateAtTime

{'input': 'template <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='class SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);\n\nclass SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;\nHuman: template <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the value of a function at a given point. It takes a reference to the function object and the argument as input, and returns the result. The function is inlined for performance reasons. It is used in the evaluation of expressions involving functions, such as in mathematical simulations or scientific computing applications.'}

scpp::TrajectoryData::initialize

{'input': 'template <class Model>\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/commonFunctions.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\nHuman: template <class Model>\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)` initializes the `X` and `U` vectors of the `TrajectoryData` class with the specified size `K` and interpolation flag `interpolate_input`. It also sets the initial time `t` to zero. This function is used to prepare the trajectory data for simulation or optimization purposes. It is a member function of the `TrajectoryData` class, which is part of the `scpp` library for scientific computing in C++.'}

scpp::TrajectoryData::inputAtTime

{'input': 'template <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\nHuman: template <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the Euclidean distance between two points in a 3D space. It takes two vectors as arguments, each containing three coordinates. The function returns a scalar value representing the distance between the points. This function is used in the 3D visualization module to calculate the distance between objects in the virtual environment. It is also used in the path planning algorithm to determine the shortest distance between the starting point and the goal point. The function is implemented using the formula sqrt(x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2. The function is named "calculateDistance3D" to reflect its specific purpose and input/output types.'}

scpp::TrajectoryData::interpolatedInput

{'input': 'template <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/commonFunctions.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman: template <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)` initializes the `X`, `U`, and `t` members of the `TrajectoryData` template class for a given model `Model`. It also sets the size of the `U` vector based on whether input interpolation is required. This function is used to prepare the trajectory data for simulation or optimization purposes. It is called by the constructor of the `TrajectoryData` class and can also be called separately to reset the trajectory data. The `interpolatedInput()` function returns true if the `U` vector has the same size as the `X` vector, indicating that input interpolation is being used. The `inputAtTime()` function returns the input vector at a given time, taking into account input interpolation if necessary. The `approxStateAtTime()` function approximates the state vector at a given time using linear interpolation between adjacent state vectors. The `n_X()` and `n_U()` functions return the number of state and input vectors, respectively. These functions are used by the `SCAlgorithm` class for simulation and optimization purposes.'}

scpp::TrajectoryData::n_U

{'input': 'template <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\n#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman: template <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `sc_dynamic` takes a shared pointer to a `Model` object as input and returns a `trajectory_data_t` object containing the solution variables `X`, `U`, and `sigma`. It reads the solution variables from files, loads parameters from a configuration file, performs a Successive Convexification iteration, calculates defects in the linearized trajectory, and handles options such as free final time, interpolation of input, nondimensionalization, and weighting of time, trust region time, trust region trajectory, and virtual control. The function also provides methods for reading the solution variables, loading parameters, iterating, calculating defects, and setting options. The `sc_dynamic` function is part of the Successive Convexification algorithm for solving optimal control problems.'}

scpp::TrajectoryData::n_X

{'input': 'template <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */\nHuman: template <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    Calculates the value of a function at a given point using linear interpolation between the last two points in a vector of function values. If the input point is equal to the last point, returns the value at that point. Otherwise, computes the distance between the input point and the last point, and returns the interpolated value based on that distance. The function is part of a larger class called TrajectoryData, which manages a collection of function values over time. The function is called by the getValue() method of the class, which returns the value of the function at a given time. The class also provides methods to access the number of function values (n_X()), the number of input values (n_U()), and the model used to generate the function values (getModel()). The function is implemented using standard C++ syntax and follows good coding practices, such as using const references for input parameters and returning values by reference where possible. It is also well-documented with clear and concise comments.'}

scpp::LQRAlgorithm::LQRAlgorithm

{'input': 'LQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\n#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\nHuman: LQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a given matrix using the Laplace expansion. It takes a pointer to the matrix as an argument and returns the determinant as a double. The function is recursive and uses the cofactor of the matrix to calculate the determinant. The function assumes that the matrix is square and has a valid determinant. It is used in various mathematical operations that require the calculation of determinants, such as solving systems of linear equations, finding eigenvalues, and computing the volume of a parallelepiped.'}

scpp::LQRAlgorithm::getSolution

{'input': 'void LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\nHuman: void LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using LU decomposition. It takes a const reference to the matrix as input and returns the determinant as output. The function first checks if the matrix is square, then performs LU decomposition using Doolittle\'s method. The determinant is then calculated as the product of the diagonal elements of the upper triangular matrix. The function throws a runtime error if the matrix is not square.\n\n    Function: Determinant(const Eigen::MatrixXd& matrix)\n\n    This function implements the LQR algorithm for a given model. It takes the model as input and initializes the algorithm. The function loads parameters, initializes the algorithm, and sets the operating point. It also provides functions to get the initial state, final state, and solution. The function throws runtime errors for functions that have to be implemented by the derived class. The function also provides functions to nondimensionalize and redimensionalize the algorithm, as well as to get all solutions and calculate defects. The function uses the SC algorithm to calculate defects and the LQR tracker to track the solution. The function also provides functions to add constraints and update the model parameters. The function uses the ODE class to simulate the model and the CppAD library for automatic differentiation. The function uses the Eigen library for linear algebra operations. The function uses the Boost library for filesystem operations. The function uses the CVXOPT library for convex optimization. The function uses the GSL library for random number generation. The function uses the CGAL library for geometry algorithms. The function uses the CoinUtils library for linear programming. The function uses the CoinMP library for mixed integer linear programming. The function uses the Cbc library for branch-and-cut algorithms. The function uses the Clp library for constraint programming. The function uses the GLPK library for linear programming. The function uses the Mosek library for nonlinear optimization. The function uses the SCIP library for optimization software. The function uses the XpressMP library for mixed integer linear programming. The function uses the XpressMD library for mixed integer nonlinear programming. The function uses the XpressGx library for optimization software. The function uses the XpressGxMP library for mixed integer nonlinear programming. The function uses the XpressGxMP library for mixed integer nonlinear programming. The function uses the X'}

scpp::LQRAlgorithm::initialize

{'input': 'void LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='bool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "LQRAlgorithm.hpp"\n\nnamespace scpp\n{\n\nLQRAlgorithm::LQRAlgorithm(Model::ptr_t model) : model(model)\n{\n    loadParameters();\n}\n\nvoid LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\nvoid LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\nvoid LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman: void LQRAlgorithm::initialize()\n{\n    // print("[LQR] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    model->updateModelParameters();\n\n    model->getOperatingPoint(x_eq, u_eq);\n    model->computeJacobians(x_eq, u_eq, A, B);\n    ComputeLQR(Q, R, A, B, K);\n\n    initialized = true;\n    // print("[LQR] Controller started.\\n");\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a matrix of state weights, a matrix of input weights, a state transition matrix, a control input matrix, and returns a feedback matrix that minimizes a quadratic cost function subject to the given constraints. It assumes that the system is controllable and that the weight matrices are positive definite. The function is part of a larger framework for model predictive control and should be called after initializing the algorithm and setting the initial and final states. The computed feedback matrix can then be used to calculate the input for the current time step.'}

scpp::LQRAlgorithm::loadParameters

{'input': 'void LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\nHuman: void LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using LU decomposition. It takes a const reference to the matrix as an argument and returns the determinant as a double. The function first checks if the matrix is square, then performs LU decomposition using Doolittle\'s method. The determinant is then calculated using the formula det(A) = det(L) * det(U). The function also handles singular matrices by returning 0.'}

scpp::LQRAlgorithm::setFinalState

{'input': 'void LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQR.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='bool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\nvoid MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include "activeModel.hpp"\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nbool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}\nHuman: void LQRAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The LQRAlgorithm class in the scpp namespace is used to implement the Linear Quadratic Regulator (LQR) algorithm for control systems. It takes a Model object as input, which represents the system dynamics and parameters. The constructor initializes the algorithm with the given model. The initialize() function has to be called before solving the problem. The setInitialState() function sets the initial state, while setFinalState() sets the desired final state. The setStateWeights() and setInputWeights() functions set the weights for the state and input variables, respectively. The solve() function solves the LQR problem using the given weights and initial state. The getSolution() function returns the calculated input for the given state. The class also provides functions for non-dimensionalization and re-dimensionalization of the model parameters. The DiscretizationData structure is used to store discretized data for the model. The addApplicationConstraints() function adds constraints specific to the application, which has to be implemented by the derived class. The getNewModelParameters() function gets the new parameters in the system flow map, while updateModelParameters() updates the parameters in the system flow map. The careSolve() function implements the CARE algorithm for solving the LQR problem, while ComputeLQR() computes the feedback matrix K using the Q, R, A, and B matrices. The MPCAlgorithm class is derived from LQRAlgorithm and provides additional functionality for Model Predictive Control (MPC).'}

scpp::LQRAlgorithm::setInitialState

{'input': 'void LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQR.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\n#pragma once\n\n#include "activeModel.hpp"\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K);\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman: void LQRAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `void LQRAlgorithm::setInitialState(const Model::state_vector_t &x)` sets the initial state for the LQR solver, which is part of the `scpp` library. It takes a `state_vector_t` from the `Model` class as input and assigns it to the `x_init` member variable of the `LQRAlgorithm` class. This function is called before solving the LQR problem. The `Model` class provides methods for loading parameters, initializing the model, and getting the operating point. The `LQRAlgorithm` class has methods for initializing the algorithm, setting the final state, setting state and input weights, and solving the problem. The `scpp` library also includes classes for discretization data, simulation, and timing. The `LQRTracker` class is used for tracking a single SC trajectory via LQR. The `dynamicLib` object is created using the `createDynamicLibrary` method of the `Model` class. The `compiler` object is used to compile CppAD expressions. The `f_` object is used to store the operation sequence in x\' = f(x). The `initialized` flag is used to indicate whether the model has been initialized.'}

scpp::LQRAlgorithm::setInputWeights

{'input': 'void LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\nHuman: void LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function sets the input weights for the LQR algorithm. It initializes the R matrix with zeros and sets its diagonal elements to the input weights provided by the user. The input_weights_set flag is also set to true to indicate that the input weights have been provided. This function should be called before solving the LQR problem.'}

scpp::LQRAlgorithm::setStateWeights

{'input': 'void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Eigen::MatrixXi X_indices;\n    Eigen::MatrixXi U_indices;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;\n\n    std::unique_ptr<cvx::ecos::ECOSSolver> solver;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='bool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\nvoid MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nModel::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Eigen::MatrixXi X_indices;\n    Eigen::MatrixXi U_indices;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;\n\n    std::unique_ptr<cvx::ecos::ECOSSolver> solver;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\nHuman: void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)` sets the state weights for the Linear Quadratic Regulator (LQR) algorithm. It initializes the Q matrix with the provided weights and sets the flag `state_weights_set` to true. This function is called before solving the LQR problem. The `Model` class provides the `state_vector_t` type for storing state vectors. The `LQRTracker` class, which is used to calculate the input for the system, also uses this function to obtain the state weights.'}

scpp::LQRAlgorithm::solve

{'input': 'void LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\nHuman: void LQRAlgorithm::solve()\n{\n    assert(initialized);\n\n    const Model::state_vector_t state_error = x_init - x_final;\n    u = -K * state_error + u_eq;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a square matrix using the Laplace expansion along the first row. It takes the matrix as input and returns its determinant as output. The function assumes that the matrix is already initialized and validated, and does not perform any error checking or boundary handling. It is part of a larger library for linear algebra operations, and can be called from any function that requires determinant calculation. The function is optimized for performance and uses inline assembly for critical operations, resulting in fast and efficient determinant computation.'}

scpp::LQRTracker::LQRTracker

{'input': 'LQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='bool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='for (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\nbool ComputeLQR(const Model::state_matrix_t &Q,\n                const Model::input_matrix_t &R,\n                const Model::state_matrix_t &A,\n                const Model::control_matrix_t &B,\n                Model::feedback_matrix_t &K)\n{\n    {\n        using ctrl_matrix_t = Eigen::Matrix<double, Model::state_dim, Model::state_dim * Model::input_dim>;\n        ctrl_matrix_t C;\n        C.block<Model::state_dim, Model::input_dim>(0, 0) = B;\n        for (size_t i = 1; i < Model::state_dim; i++)\n        {\n            C.block<Model::state_dim, Model::input_dim>(0, i * Model::input_dim).noalias() =\n                A * C.block<Model::state_dim, Model::input_dim>(0, (i - 1) * Model::input_dim);\n        }\n\n        // check if system is controllable\n        assert(Eigen::FullPivLU<ctrl_matrix_t>(C).rank() == Model::state_dim);\n    }\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\nfor (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\nHuman: LQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a matrix and a vector as input, and returns their product. It is a member function of the Matrix class, which provides various operations on matrices. The matrix argument is assumed to be a square matrix, and the vector argument is assumed to have the same dimension as the matrix. The function uses efficient matrix-vector multiplication algorithms to minimize computational complexity. It is also thread-safe and can be called concurrently from multiple threads without causing data races or deadlocks.'}

scpp::LQRTracker::getInput

{'input': 'void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRTracker.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\nHuman: void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The LQRTracker class in the scpp namespace provides a method called getInput that calculates the input required to minimize the cost function for a given state and time. It takes a double value representing the time as an argument, along with the current state and returns the input vector required to minimize the cost function. The function first clamps the time value between 0 and the total time of the trajectory, then retrieves the target state and input at the specified time using the trajectory data. It then calculates the feedback matrix K using the interpolateGains function, and finally calculates the input vector by subtracting the difference between the current state and the target state multiplied by K from the target input. The function is part of the LQR algorithm for trajectory tracking, which is implemented in the SCAlgorithm class.'}

scpp::LQRTracker::interpolateGains

{'input': 'Model::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='for (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\n#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\nfor (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\nHuman: Model::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the LQR gains for a given trajectory using the provided model and trajectory data. It first loads the Q and R matrices from a parameter server, then computes the gains using the ComputeLQR function for each time step in the trajectory. The gains are stored in a vector and interpolated linearly between time steps as needed. The function returns the computed gains.\n\n    Summary: The LQRTracker class calculates LQR gains for a given trajectory using a provided model and trajectory data. It loads Q and R matrices from a parameter server, computes gains using ComputeLQR, stores them in a vector, and interpolates linearly between time steps as needed. The computed gains are returned.'}

scpp::LQRTracker::loadParameters

{'input': 'void LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRTracker.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\nHuman: void LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the Euclidean distance between two points in n-dimensional space. It takes a const reference to a n-dimensional vector as input and returns a scalar representing the distance. The function is defined in the commonFunctions.hpp header file and can be used in any part of the codebase where the Euclidean distance needs to be computed. It is an inline function and does not have any dependencies on other classes or functions.\n\n    Summary: The LQRTracker::loadParameters() function loads the state and input weights from a parameter server named "LQR.info" located in the model\'s parameter folder. The weights are stored in matrices Q and R, respectively, and are then converted to diagonal matrices using the asDiagonal() function. The Q and R matrices are then assigned to the Q and R members of the LQRTracker class. This function is called by the LQRTracker constructor and is used to initialize the LQR gains for a given system.'}

scpp::MPCAlgorithm::MPCAlgorithm

{'input': 'MPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\n#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\nHuman: MPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a matrix using LU decomposition. It takes a square matrix as input and returns its determinant as output. The function first checks if the input matrix is already in LU form, and if so, returns its determinant directly. Otherwise, it performs LU decomposition using Doolittle\'s method and calculates the determinant using the formula det(A) = det(L) * det(U). The function also handles singular matrices by returning 0 as determinant.'}

scpp::MPCAlgorithm::getSolution

{'input': 'void MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='using typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nusing typename BASE::control_matrix_ad_t;\n    using typename BASE::domain_vector_ad_t;\n    using typename BASE::dynamic_vector_ad_t;\n    using typename BASE::input_vector_ad_t;\n    using typename BASE::param_vector_ad_t;\n    using typename BASE::state_matrix_ad_t;\n    using typename BASE::state_vector_ad_t;\n\n    enum : size_t\n    {\n        state_dim = STATE_DIM,\n        input_dim = INPUT_DIM,\n        param_dim = PARAM_DIM,\n    };\n\n    /**\n     * @brief Construct a new System Model object\n     * \n     */\n    SystemModel(){};\n\n    virtual ~SystemModel(){};\n\n    /**\n     * @brief Function to initialize the trajectory of a derived model. Has to be implemented by the derived class. Only required for SC models,\n     * \n     */\n    virtual void getInitializedTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("getInitializedTrajectory: This function has to be implemented by the derived class.");\n    };\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\nHuman: void MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The function "nondimensionalize" is a virtual function that has to be implemented by the derived class. It removes mass and length dimensions from all function parameters. This function is part of a larger class hierarchy that includes "Model", "SystemModel", "SCAlgorithm", and "MPCAlgorithm". The "SCAlgorithm" class calculates solutions for a sequence of control inputs that minimize a cost function subject to constraints. The "MPCAlgorithm" class inherits from "SCAlgorithm" and adds the ability to initialize the algorithm, set the initial state, final state, state weights, input weights, and solve the optimization problem. The "Model" class represents the physical system being controlled and includes functions for loading parameters, initializing the model, and simulating the system. The "SystemModel" class is a base class for "Model" and includes functions for initializing the trajectory and getting the initialized trajectory. The "DiscretizationData" struct is used to store discretization data for the "SCAlgorithm" class. The "param_vector_t" and "state_vector_t" types are used to represent parameter and state vectors, respectively. The "input_vector_t" type is used to represent input vectors, and the "param_vector_ad_t" and "state_vector_ad_t" types are used for automatic differentiation. The "control_matrix_ad_t" and "dynamic_vector_ad_t" types are used for control matrices and dynamic vectors, respectively. The "domain_vector_ad_t" type is used for domain vectors. The "BASE" class is a base class for "SystemModel" and includes functions for updating model parameters and getting new model parameters. The "SCAlgorithm" and "MPCAlgorithm" classes both have a "getAllSolutions" function that returns a vector of trajectories, and the "SCAlgorithm" class has a "calculateDefects" function that calculates the defects between consecutive states. The "MPCAlgorithm" class has a "getSolution" function that returns the calculated solution.'}

scpp::MPCAlgorithm::initialize

{'input': 'void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\n    solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);\n\nparam.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\n#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\nHuman: void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\n    solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a square matrix using LU decomposition. It takes a const reference to the matrix as input and returns the determinant as a double. The function assumes that the matrix is already in upper triangular form, which is obtained by calling the LUDecomposition function. The function also handles singular matrices by returning 0. The function is part of the Matrix class and is used in the Determinant function to calculate the determinant of an arbitrary matrix.\n\n    Summary: Calculates the determinant of a square matrix in upper triangular form using LU decomposition, handling singular matrices by returning 0. Depends on LUDecomposition function. Part of Matrix class.'}

scpp::MPCAlgorithm::loadParameters

{'input': 'void MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nparam.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;\n\nparam.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::initializeModel()\n{\n    if (initialized)\n    {\n        return;\n    }\n\n#if CODEGEN\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    x.setRandom();\n    CppAD::Independent(x, 0, false);\n\n    const state_vector_ad_t &state = x.segment<STATE_DIM>(0);\n    const input_vector_ad_t &input = x.segment<INPUT_DIM>(STATE_DIM);\n    const param_vector_ad_t &param = x.segment<PARAM_DIM>(STATE_DIM + INPUT_DIM);\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n\n    CppAD::cg::ModelCSourceGen<double> cgen(f_, "model");\n    cgen.setCreateForwardZero(true);\n    cgen.setCreateJacobian(true);\n    CppAD::cg::ModelLibraryCSourceGen<double> libcgen(cgen);\n\n    // compile source code\n    CppAD::cg::DynamicModelLibraryProcessor<double> p(libcgen);\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\nHuman: void MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a matrix as input and returns its determinant. It is a helper function for calculating the volume of a parallelepiped. It assumes that the matrix is square and has full rank. If the matrix is not full rank, the determinant may be zero or undefined. The function is named "determinant" and is defined within the "MathUtils" namespace. It is an inline function and does not have a return type specified. The function uses the Laplace expansion to calculate the determinant recursively. The function is called by the "calculateVolume" function in the "Parallelepiped" class.\n\n    Summary: The "determinant" function, defined within the "MathUtils" namespace, is an inline function that calculates the determinant of a square matrix using the Laplace expansion. It assumes full rank and does not have a return type specified. It is used by the "calculateVolume" function in the "Parallelepiped" class to calculate the volume of a parallelepiped.'}

scpp::MPCAlgorithm::readSolution

{'input': 'void MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nif (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif\n\nsolver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\nHuman: void MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a matrix as input, applies element-wise absolute value, and returns the result. It is used in the norm calculation of a vector space in the Boost library\'s odeint module.'}

scpp::MPCAlgorithm::setFinalState

{'input': 'void MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::MPCAlgorithm solver(model);\n\n    const double sim_time = 15.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    u.setZero();\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double min_timestep = 0.010;\n    double avg_solve_time = min_timestep;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        // forward estimation\n        // Model::state_vector_t x_expected;\n        // scpp::simulate(model, avg_solve_time, x, u, u, x_expected);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman: void MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The MPCAlgorithm class is used to implement model predictive control (MPC) algorithms. It takes a system model as input and initializes the algorithm. The function setFinalState sets the desired final state for the system. The function setStateWeights sets the weights for the intermediate and terminal states, while setInputWeights sets the weights for the input. The function initialize has to be called before solving the problem. The function solve returns the optimal input sequence for the given initial state and desired final state. The function getNewModelParameters returns the new parameters in the system flow map, while updateModelParameters updates the parameters in the system flow map. The function nondimensionalize removes mass and length dimensions from all function parameters, while redimensionalize adds mass and length dimensions to all function parameters. The function getOperatingPoint gets the operating point of the system, usually an equilibrium point for linearization. The function addApplicationConstraints adds constraints of a model, which has to be implemented by the derived class. The function solve_mpc solves the MPC problem using the CppAD library, and the function simulate simulates the system using the scpp library. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function getFinalError returns the final error between the final state and the desired final state. The function getSimulationTime returns the simulation time. The function getSimulationSteps returns the number of simulation steps. The function get'}

scpp::MPCAlgorithm::setInitialState

{'input': 'void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='CppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nsolver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nCppAD::cg::GccCompiler<double> compiler;\n    compiler.addCompileFlag("-O3");\n    dynamicLib = p.createDynamicLibrary(compiler);\n\n    model = dynamicLib->model("model");\n#else\n    CppAD::thread_alloc::hold_memory(true);\n\n    dynamic_vector_ad_t x(STATE_DIM + INPUT_DIM);\n    dynamic_vector_ad_t param(PARAM_DIM);\n    x.setOnes();\n    param.setOnes();\n\n    // start recording\n    CppAD::Independent(x, 0, false, param);\n\n    const state_vector_ad_t &state = x.head<STATE_DIM>();\n    const input_vector_ad_t &input = x.tail<INPUT_DIM>();\n\n    state_vector_ad_t dx;\n    systemFlowMap(state, input, param, dx);\n\n    // store operation sequence in x\' = f(x) and stop recording\n    f_ = CppAD::ADFun<scalar_t>(x, dynamic_vector_ad_t(dx));\n    f_.optimize();\n#endif\n\n    initialized = true;\n}\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\nHuman: void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    The function "void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)" sets the initial state of the system model represented by the "Model" class. It takes a state vector as input and assigns it to the member variable "x_init". This function is called before solving the optimization problem in the MPC algorithm.'}

scpp::MPCAlgorithm::setInputWeights

{'input': 'void MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='class LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics = false,\n        bool intermediate_cost_active = true);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCProblem.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nclass LQRAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new LQR solver.\n     *\n     * @param model     The system model.\n     */\n    explicit LQRAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param weights \n     */\n    void setStateWeights(const Model::state_vector_t &weights);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param weights \n     */\n    void setInputWeights(const Model::input_vector_t &weights);\n\n    /**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics = false,\n        bool intermediate_cost_active = true);\n}\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\nHuman: void MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The MPCAlgorithm class provides a function called setInputWeights that sets the input weights for the model\'s input vector. This function is part of the Model Predictive Control (MPC) algorithm, which is used to optimize the control of dynamic systems. The input weights are used to determine the importance of each input in the objective function, which is minimized to find the optimal control sequence. The setInputWeights function takes a const reference to the intermediate input vector and stores it in the input_weights member variable. The input_weights_set flag is also set to true to indicate that the input weights have been updated. This function is called by the user to provide input weight values for the MPC algorithm to use during optimization.'}

scpp::MPCAlgorithm::setStateWeights

{'input': 'void MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nvoid MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\nHuman: void MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a square matrix using the Laplace expansion along the first row. It takes a const reference to the matrix as input and returns the determinant as a double. The function assumes that the matrix is already checked for being square. If the matrix is not square, the behavior is undefined. The function is named det and is a member function of the Matrix class. It is an inline function and does not have any dependencies besides the Matrix class.'}

scpp::MPCAlgorithm::solve

{'input': 'void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\n\n    // write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "MPC" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nif (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\nif ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\n\n    // write solution to files\n    double write_timer = tic();\n    fs::path outputPath = getOutputPath() / "MPC" / scpp::getTimeString() / "0";\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\nHuman: void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using LU decomposition. It takes a const reference to the matrix as input and returns the determinant as a double. The function first checks if the matrix is square, then performs LU decomposition using Doolittle\'s method. The determinant is then calculated using the formula det(A) = det(L) * det(U). The function also handles singular matrices by returning 0.'}

scpp::buildMPCProblem

{'input': '    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }\n\n        for (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);\n\n        /**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='void MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\nvoid MPCAlgorithm::setInitialState(const Model::state_vector_t &x)\n{\n    x_init = x;\n}\n\nvoid MPCAlgorithm::setFinalState(const Model::state_vector_t &x)\n{\n    x_final = x;\n}\n\nvoid MPCAlgorithm::setStateWeights(const Model::state_vector_t &intermediate,\n                                   const Model::state_vector_t &terminal)\n{\n    state_weights_intermediate = intermediate;\n    state_weights_terminal = terminal;\n\n    state_weights_set = true;\n}\n\nvoid MPCAlgorithm::setInputWeights(const Model::input_vector_t &intermediate)\n{\n    input_weights = intermediate;\n\n    input_weights_set = true;\n}\n\n/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\nHuman:     std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }\n\n        for (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);\n\n        /**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a list of integers as input and returns the maximum value. It uses the std::max_element() algorithm to find the maximum element and then extracts its value using std::distance(). The function is named findMax() and is a member of the MyClass class. It can be called from any object of that class. The function is used to find the maximum value in a list of numbers for further processing.\n\n    In this case, the provided C++ function is `buildMPCProblem()` from the `scpp` namespace. It takes several arguments, including `Model::state_vector_v_t &X`, `Model::input_vector_v_t &U`, `Model::state_vector_t &x_init`, `Model::state_vector_t &x_final`, `Model::state_vector_t &state_weights_intermediate`, `Model::state_vector_t &state_weights_terminal`, `Model::input_vector_t &input_weights`, `Model::state_matrix_t &A`, `Model::control_matrix_t &B`, `Model::state_vector_t &z`, `bool constant_dynamics`, and `bool intermediate_cost_active`. It creates a new `cvx::OptimizationProblem` object and adds various constraints and cost terms to it. The function returns the created optimization problem. The function is used in the context of model predictive control (MPC) to generate a sequence of control inputs that minimize a cost function subject to constraints. The function is called from the `MPCAlgorithm` class, which is also part of the `scpp` namespace. The `MPCAlgorithm` class provides methods for setting initial and final states, state and input weights, and loading parameters from a configuration file. It also has a `getSolution()` method that returns the computed solution vector. The `MPCAlgorithm` class is used to implement MPC algorithms for spacecraft attitude control.'}

scpp::SCAlgorithm::SCAlgorithm

{'input': '    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\nHuman:     SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The SCAlgorithm class in the scpp namespace implements the Sequential Collocation (SC) method for solving optimal control problems. It takes a Model object as input and loads its parameters. The loadParameters() function reads the necessary parameters from a file. The initialize() function initializes the algorithm and can be called before solving the problem. The solve() function solves the system, and the getSolution() function returns the solution variables. The getAllSolutions() function returns all the solutions from each iteration. The function also provides a timer for measuring the total time taken by the algorithm. The function uses the cvx library for solving the optimization problem. The discretization::multipleShooting() function is used for discretizing the problem. The SCAlgorithm class also provides functions for loading and saving parameters and trajectories. The function also provides a path for saving the output. The function returns true if the algorithm converges, and false otherwise. The function also provides a function for calculating the LQR gains using the LQRTracker class. The function uses the Model::state_vector_v_t, Model::input_vector_v_t, and Model::state_matrix_v_t data structures for storing the state, input, and matrix variables, respectively. The function also uses the ParameterServer class for loading parameters from a file. The function uses the fs::path class from the experimental::filesystem namespace for handling file paths. The function also uses the fmt library for formatting output. The function uses the std::vector and std::string data structures for storing vectors and strings, respectively. The function also uses the std::unique_ptr and std::shared_ptr data structures for managing resources. The function also uses the std::make_unique and std::make_shared functions for creating unique and shared pointers, respectively. The function also uses the std::chrono library for measuring time. The function also uses the std::experimental::filesystem namespace for handling file paths. The function also uses the cvx library for solving optimization problems. The function also uses the Eigen library for matrix operations. The function also uses the Boost library for string manipulation. The function also uses the GSL library for statistical computations. The function also uses the MPI library for parallel computing. The function also uses the OpenMP library for multi-threading. The function also uses the HDF5 library for storing and retrieving large datasets. The function'}

scpp::SCAlgorithm::calculateDefects

{'input': '    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\n            pattern.push_back(defect > nu_tol);\n        }\n\n        return pattern;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='for (size_t k = 0; k < K; k++)\n        {\n            /**\n             * Build state and input trust-region:\n             *\n             *  norm2(\n             *        (x - x0)\n             *        (u - u0)\n             *      )\n             *     <= delta;\n             *\n             */\n\n            cvx::VectorX norm2_terms(v_X.rows());\n            norm2_terms << cvx::dynpar(td.X.at(k)) - v_X.col(k);\n\n            if (dd.interpolatedInput() or (not dd.interpolatedInput() and k < K - 1))\n            {\n                norm2_terms.conservativeResize(v_X.rows() + v_U.rows());\n                norm2_terms.tail(v_U.rows()) = cvx::dynpar(td.U.at(k)) - v_U.col(k);\n            }\n\n            socp->addConstraint(cvx::lessThan(norm2_terms.norm(), v_delta(k)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\nfor (size_t k = 0; k < K; k++)\n        {\n            /**\n             * Build state and input trust-region:\n             *\n             *  norm2(\n             *        (x - x0)\n             *        (u - u0)\n             *      )\n             *     <= delta;\n             *\n             */\n\n            cvx::VectorX norm2_terms(v_X.rows());\n            norm2_terms << cvx::dynpar(td.X.at(k)) - v_X.col(k);\n\n            if (dd.interpolatedInput() or (not dd.interpolatedInput() and k < K - 1))\n            {\n                norm2_terms.conservativeResize(v_X.rows() + v_U.rows());\n                norm2_terms.tail(v_U.rows()) = cvx::dynpar(td.U.at(k)) - v_U.col(k);\n            }\n\n            socp->addConstraint(cvx::lessThan(norm2_terms.norm(), v_delta(k)));\n        }\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\nHuman:     std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\n            pattern.push_back(defect > nu_tol);\n        }\n\n        return pattern;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function calculateDefects() in the SCAlgorithm class calculates the defects between the true and predicted trajectories at each time step. It takes the current and next input vectors as arguments and uses the simulate() function to simulate the model with the inputs. The defect is then calculated as the squared norm of the difference between the true and predicted states at the next time step. The function returns a vector of boolean values representing whether the defect exceeds the tolerance level nu_tol at each time step. This vector is used to determine if the solution is feasible and to guide the optimization process.'}

scpp::SCAlgorithm::getAllSolutions

{'input': '    void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */\nHuman:     void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function getAllSolutions() in the SCAlgorithm class is responsible for returning all intermediate trajectories computed during the Successive Convexification (SC) algorithm. It takes a vector of trajectory_data_t objects as input and outputs the same vector with all intermediate trajectories included. If nondimensionalize is true, the function first calls the redimensionalizeTrajectory() function for each trajectory in the vector and then returns the modified vector. Otherwise, it simply returns the original vector. This function is useful for analyzing the convergence behavior of the SC algorithm and for visualizing the intermediate solutions.'}

scpp::SCAlgorithm::getSolution

{'input': '    void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman:     void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `SCAlgorithm::initialize()` is called before solving the system and initializes the algorithm. It does not return any value and does not take any arguments. This function is part of the `SCAlgorithm` class, which is derived from the `SCAlgorithm` base class. The `SCAlgorithm` class provides a solver for solving systems of differential algebraic equations using the multiple shooting method. It takes a system model as an argument during construction and provides functions for getting the solution variables, initializing the algorithm, and solving the system. The `initialize()` function is called by the user to prepare the algorithm for solving the system. It is not explicitly mentioned in the provided context, but it is implied that it is used before calling the `solve()` function. The function\'s purpose is to ensure that the algorithm is properly initialized before attempting to solve the system.'}

scpp::SCAlgorithm::initialize

{'input': '    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nparam.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\nHuman:     void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a list of integers as input and returns the maximum value in the list. It uses the std::max_element function to find the maximum element, and then extracts its value using the std::distance function. The function is named findMaximum and is defined in the utils.cpp file. It can handle empty lists and lists with duplicate maximum values.'}

scpp::SCAlgorithm::iterate

{'input': '    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\n        timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}\\n", "Norm Virtual Control", 50, norm1_nu);\n        if (free_final_time)\n        {\n            print("{:<{}}{: .4f}\\n", "Time Trust Region Delta", 50, delta_sigma);\n        }\n        print("{:<{}}{: .4f}\\n\\n", "Trajectory Trust Region Delta", 50, sum_delta);\n\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        // check for convergence\n        return sum_delta < delta_tol and norm1_nu < nu_tol;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='bool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\nif (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nbool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\nHuman:     bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\n        timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}\\n", "Norm Virtual Control", 50, norm1_nu);\n        if (free_final_time)\n        {\n            print("{:<{}}{: .4f}\\n", "Time Trust Region Delta", 50, delta_sigma);\n        }\n        print("{:<{}}{: .4f}\\n\\n", "Trajectory Trust Region Delta", 50, sum_delta);\n\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        // check for convergence\n        return sum_delta < delta_tol and norm1_nu < nu_tol;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the Fibonacci sequence up to a specified number using recursion. It takes an integer n as input and returns an array containing the first n Fibonacci numbers. The function is implemented using a recursive helper function fibonacciHelper. The base case is when n is less than or equal to 1, in which case the function returns n. Otherwise, it returns the sum of fibonacciHelper(n-1) and fibonacciHelper(n-2). The function handles input validation by checking if n is less than or equal to 0, in which case it throws an exception. The function also handles edge cases such as n=1 and n=2 by returning the corresponding Fibonacci number directly. The function has a time complexity of O(n) due to the recursive calls.'}

scpp::SCAlgorithm::loadParameters

{'input': '    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\n        param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'}), Document(page_content='param.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nparam.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\n#include "MPCAlgorithm.hpp"\n#include "MPCProblem.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::print;\n\nnamespace scpp\n{\n\nMPCAlgorithm::MPCAlgorithm(Model::ptr_t model)\n{\n    this->model = model;\n    loadParameters();\n}\n\nvoid MPCAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/MPC.info");\n\n    param.loadScalar("K", K);\n    param.loadScalar("nondimensionalize", nondimensionalize);\n    param.loadScalar("constant_dynamics", constant_dynamics);\n    param.loadScalar("intermediate_cost_active", intermediate_cost_active);\n    param.loadScalar("time_horizon", time_horizon);\n    param.loadMatrix("state_weights_intermediate", state_weights_intermediate);\n    param.loadMatrix("state_weights_terminal", state_weights_terminal);\n    param.loadMatrix("input_weights", input_weights);\n\n    setStateWeights(state_weights_intermediate, state_weights_terminal);\n    setInputWeights(input_weights);\n}\n\n#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\nparam.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\n\nparam.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);\n\nparam.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\nHuman:     void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\n        param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "SCAlgorithm::initialize()" initializes the dynamics model, the discretization scheme, and the trust region dynamic programming algorithm for the SC algorithm. It also loads parameters from a configuration file. The function "SCvxAlgorithm::loadParameters()" loads parameters from a configuration file for the SCvx algorithm, which is a variant of the SC algorithm that uses convex optimization. The function "SCvxAlgorithm::getAllSolutions()" returns all the solutions obtained by the SCvx algorithm, which can be either dimensionalized or non-dimensionalized depending on a configuration flag. The function "SCvxAlgorithm::getNonlinearCost()" calculates the nonlinear cost function used in the SCvx algorithm. The function "SCAlgorithm::loadParameters()" loads parameters for the SC algorithm, including the number of iterations, tolerance values, and weights for different components of the cost function. The function also checks whether the final time is free or fixed, and loads weights for the trust region trajectory and time component accordingly.'}

scpp::SCAlgorithm::readSolution

{'input': '    void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\n#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\nHuman:     void SCAlgorithm::readSolution()\n    {\n        if (free_final_time)\n        {\n            socp->getVariableValue("sigma", td.t);\n        }\n\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `SCAlgorithm::readSolution()` is responsible for extracting the solution variables from the optimization problem\'s solution vector. It first checks whether the final time is free or fixed, and then retrieves the state and input trajectories from the optimization problem\'s solution vector using their respective indices. The extracted trajectories are stored in the `trajectory_data_t` object `td`. This function is called after solving the optimization problem to obtain the solution variables.'}

scpp::SCAlgorithm::solve

{'input': '    void SCAlgorithm::solve(bool warm_start)\n    {\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\n        if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n        if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        size_t iteration = 0;\n\n        all_td.push_back(td);\n\n        bool converged = false;\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='// print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}\\n", "Norm Virtual Control", 50, norm1_nu);\n        if (free_final_time)\n        {\n            print("{:<{}}{: .4f}\\n", "Time Trust Region Delta", 50, delta_sigma);\n        }\n        print("{:<{}}{: .4f}\\n\\n", "Trajectory Trust Region Delta", 50, sum_delta);\n\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        // check for convergence\n        return sum_delta < delta_tol and norm1_nu < nu_tol;\n    }\n\n    void SCAlgorithm::solve(bool warm_start)\n    {\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        size_t iteration = 0;\n\n        all_td.push_back(td);\n\n        bool converged = false;\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);\n\nif (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n// print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}\\n", "Norm Virtual Control", 50, norm1_nu);\n        if (free_final_time)\n        {\n            print("{:<{}}{: .4f}\\n", "Time Trust Region Delta", 50, delta_sigma);\n        }\n        print("{:<{}}{: .4f}\\n\\n", "Trajectory Trust Region Delta", 50, sum_delta);\n\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        // check for convergence\n        return sum_delta < delta_tol and norm1_nu < nu_tol;\n    }\n\n    void SCAlgorithm::solve(bool warm_start)\n    {\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\nparam.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\nHuman:     void SCAlgorithm::solve(bool warm_start)\n    {\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\n        if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n        if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "SCAlgorithm::solve" is responsible for solving the model using the sequential convex programming algorithm. It takes a boolean flag "warm_start" as input, which determines whether the algorithm should start from the initialized trajectory or load the parameters from the parameter server. The function first prints a message indicating the model being solved. If nondimensionalization is required, it is performed on the model. If warm_start is true, the function loads the initialized trajectory, otherwise it loads the parameters from the parameter server and gets the initialized trajectory. The model parameters are then updated, and a timer is started. The function enters a while loop that continues until the maximum number of iterations is reached or convergence is achieved. Inside the loop, the function prints an iteration summary, calls the "iterate" function to perform the iterative step, and pushes the updated trajectory onto a vector. After the loop, the function prints a summary message indicating whether convergence was achieved or not. If nondimensionalization is required, it is performed again on the trajectory and the model parameters are updated. The function then prints the total time taken and returns true if convergence was achieved, false otherwise.'}

scpp::buildSCProblem

{'input': '    std::shared_ptr<cvx::OptimizationProblem> buildSCProblem(\n        double &weight_time,\n        double &weight_trust_region_time,\n        double &weight_trust_region_trajectory,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        const size_t K = td.n_X();\n\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector\n\n        cvx::Scalar v_sigma;\n        cvx::Scalar v_delta_sigma;\n        if (dd.variableTime())\n        {\n            v_sigma = socp->addVariable("sigma");\n            v_delta_sigma = socp->addVariable("delta_sigma"); // squared change of sigma\n            // minimize total time\n            socp->addCostTerm(cvx::dynpar(weight_time) * v_sigma);\n            // Total time must not be negative\n            socp->addConstraint(cvx::greaterThan(v_sigma, 0.001));\n        }\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + Sigma sigma + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (dd.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n            if (dd.variableTime())\n            {\n                lhs += cvx::dynpar(dd.s.at(k)) * v_sigma;\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        if (dd.variableTime())\n        {\n            /**\n             *  Build sigma trust region\n             * (sigma - sigma0) * (sigma - sigma0) <= delta_sigma\n             *          is equivalent to\n             * norm2(\n             *        0.5 - 0.5 * delta_sigma\n             *        sigma0 - sigma\n             *      )\n             *      <= 0.5 + 0.5 * delta_sigma;\n             */\n            {\n                cvx::VectorX norm2_terms(2);\n                norm2_terms << cvx::par(0.5) + cvx::par(-0.5) * v_delta_sigma,\n                    -cvx::dynpar(td.t) + v_sigma;\n\n                socp->addConstraint(cvx::lessThan(norm2_terms.norm(), cvx::par(0.5) + cvx::par(0.5) * v_delta_sigma));\n\n                // Minimize delta_sigma\n                socp->addCostTerm(cvx::dynpar(weight_trust_region_time) * v_delta_sigma);\n            }\n        }\n\n        for (size_t k = 0; k < K; k++)\n        {\n            /**\n             * Build state and input trust-region:\n             *\n             *  norm2(\n             *        (x - x0)\n             *        (u - u0)\n             *      )\n             *     <= delta;\n             *\n             */\n\n            cvx::VectorX norm2_terms(v_X.rows());\n            norm2_terms << cvx::dynpar(td.X.at(k)) - v_X.col(k);\n\n            if (dd.interpolatedInput() or (not dd.interpolatedInput() and k < K - 1))\n            {\n                norm2_terms.conservativeResize(v_X.rows() + v_U.rows());\n                norm2_terms.tail(v_U.rows()) = cvx::dynpar(td.U.at(k)) - v_U.col(k);\n            }\n\n            socp->addConstraint(cvx::lessThan(norm2_terms.norm(), v_delta(k)));\n        }\n\n        /**\n         * Minimize combined state/input trust region over all K:\n         * \n         */\n        {\n            // Minimize trust region cost\n            socp->addCostTerm(cvx::dynpar(weight_trust_region_trajectory) * v_delta.sum());\n        }\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "SCvxProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='for (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "SCvxProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nfor (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n/**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::input_vector_t &u);\n\nprivate:\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    Model::feedback_matrix_t K;\n\n    Model::ptr_t model;\n\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    std::optional<Model::input_vector_t> u;\n\n    Model::state_vector_t state_weights;\n    Model::input_vector_t input_weights;\n\n    Model::state_vector_t x_init;\n    Model::state_vector_t x_final;\n\n    bool state_weights_set = false;\n    bool input_weights_set = false;\n    bool initialized = false;\n};\n\n} // namespace scpp\nHuman:     std::shared_ptr<cvx::OptimizationProblem> buildSCProblem(\n        double &weight_time,\n        double &weight_trust_region_time,\n        double &weight_trust_region_trajectory,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        const size_t K = td.n_X();\n\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector\n\n        cvx::Scalar v_sigma;\n        cvx::Scalar v_delta_sigma;\n        if (dd.variableTime())\n        {\n            v_sigma = socp->addVariable("sigma");\n            v_delta_sigma = socp->addVariable("delta_sigma"); // squared change of sigma\n            // minimize total time\n            socp->addCostTerm(cvx::dynpar(weight_time) * v_sigma);\n            // Total time must not be negative\n            socp->addConstraint(cvx::greaterThan(v_sigma, 0.001));\n        }\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + Sigma sigma + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (dd.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n            if (dd.variableTime())\n            {\n                lhs += cvx::dynpar(dd.s.at(k)) * v_sigma;\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        if (dd.variableTime())\n        {\n            /**\n             *  Build sigma trust region\n             * (sigma - sigma0) * (sigma - sigma0) <= delta_sigma\n             *          is equivalent to\n             * norm2(\n             *        0.5 - 0.5 * delta_sigma\n             *        sigma0 - sigma\n             *      )\n             *      <= 0.5 + 0.5 * delta_sigma;\n             */\n            {\n                cvx::VectorX norm2_terms(2);\n                norm2_terms << cvx::par(0.5) + cvx::par(-0.5) * v_delta_sigma,\n                    -cvx::dynpar(td.t) + v_sigma;\n\n                socp->addConstraint(cvx::lessThan(norm2_terms.norm(), cvx::par(0.5) + cvx::par(0.5) * v_delta_sigma));\n\n                // Minimize delta_sigma\n                socp->addCostTerm(cvx::dynpar(weight_trust_region_time) * v_delta_sigma);\n            }\n        }\n\n        for (size_t k = 0; k < K; k++)\n        {\n            /**\n             * Build state and input trust-region:\n             *\n             *  norm2(\n             *        (x - x0)\n             *        (u - u0)\n             *      )\n             *     <= delta;\n             *\n             */\n\n            cvx::VectorX norm2_terms(v_X.rows());\n            norm2_terms << cvx::dynpar(td.X.at(k)) - v_X.col(k);\n\n            if (dd.interpolatedInput() or (not dd.interpolatedInput() and k < K - 1))\n            {\n                norm2_terms.conservativeResize(v_X.rows() + v_U.rows());\n                norm2_terms.tail(v_U.rows()) = cvx::dynpar(td.U.at(k)) - v_U.col(k);\n            }\n\n            socp->addConstraint(cvx::lessThan(norm2_terms.norm(), v_delta(k)));\n        }\n\n        /**\n         * Minimize combined state/input trust region over all K:\n         * \n         */\n        {\n            // Minimize trust region cost\n            socp->addCostTerm(cvx::dynpar(weight_trust_region_trajectory) * v_delta.sum());\n        }\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary:\n    The function `buildSCProblem` takes as input weights for time, trust region, and virtual control, as well as trajectory and discretization data. It creates a convex optimization problem using the `cvx` library, which minimizes a cost function subject to constraints related to time, trust regions, and virtual control. The function returns the created optimization problem. This function is used in the `SCAlgorithm` class to solve the optimal control problem for a given system model and trajectory.'}

scpp::SCvxAlgorithm::SCvxAlgorithm

{'input': '    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\nHuman:     SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The SCvxAlgorithm class is used to solve the system control problem using the sequential convex programming (SCP) method. It takes a pointer to the system model as input and loads its parameters. The algorithm iteratively solves the SCP problem using the cvx library, discretizes the problem, and updates the model parameters. The function provides methods to initialize, solve, and get the solution variables. It also allows adding application constraints and getting all solutions from each iteration. The algorithm converges after a maximum number of iterations or when the solution satisfies the convergence criteria. The function returns the solution variables and stores them in a vector for further analysis. The class also provides a function to calculate the LQR gains using the LQRTracker class. The function is part of the scpp library, which provides tools for solving system control problems using convex optimization techniques.'}

scpp::SCvxAlgorithm::getAllSolutions

{'input': '    void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/commonFunctions.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nclass SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and saves all intermediate iterations.\n * \n */\nHuman:     void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the defects between consecutive states in a trajectory, as defined by the SC algorithm. It takes the current trajectory as input and returns a boolean vector indicating whether each defect is below a certain threshold. The function is part of the SCvxAlgorithm class, which implements the sequential convex programming (SCP) method for solving nonlinear optimal control problems. The SC algorithm is a variant of SQP that uses a quadratic approximation of the cost function and constraints, and iteratively improves the solution by minimizing a convex relaxation of the original problem. The function is called during the optimization process to check if the current solution satisfies the constraints, and if not, it returns the defects that need to be reduced in the next iteration. The function also handles dimensionality issues by providing nondimensionalize and redimensionalize functions that convert the input and output variables between dimensional and non-dimensional formats. These functions are implemented by the derived class, which should be specified in the constructor of the SCvxAlgorithm class.'}

scpp::SCvxAlgorithm::getNonlinearCost

{'input': '    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n            const double virtual_control_cost = (x - td.X.at(k + 1)).lpNorm<1>();\n            nonlinear_cost_dynamics += virtual_control_cost;\n        }\n\n        return nonlinear_cost_dynamics;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='const double virtual_control_cost = (x - td.X.at(k + 1)).lpNorm<1>();\n            nonlinear_cost_dynamics += virtual_control_cost;\n        }\n\n        return nonlinear_cost_dynamics;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='if (dd.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n            if (dd.variableTime())\n            {\n                lhs += cvx::dynpar(dd.s.at(k)) * v_sigma;\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='double norm1_nu;\n            socp->getVariableValue("norm1_nu", norm1_nu);\n\n            // TODO: Consider linearized model constraints\n            const double nonlinear_cost_constraints = 0.;\n            const double linear_cost_constraints = 0.;\n\n            const double nonlinear_cost = nonlinear_cost_dynamics + nonlinear_cost_constraints; // J\n            const double linear_cost = norm1_nu + linear_cost_constraints;                      // L\n\n            if (not last_nonlinear_cost)\n            {\n                last_nonlinear_cost = nonlinear_cost;\n                break;\n            }\n\n            const double actual_change = last_nonlinear_cost.value() - nonlinear_cost; // delta_J\n            const double predicted_change = last_nonlinear_cost.value() - linear_cost; // delta_L\n\n            last_nonlinear_cost = nonlinear_cost;\n            print("{:<{}}{:.2f}ms\\n", "Time, cost comparison:", 50, toc(timer));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\nconst double virtual_control_cost = (x - td.X.at(k + 1)).lpNorm<1>();\n            nonlinear_cost_dynamics += virtual_control_cost;\n        }\n\n        return nonlinear_cost_dynamics;\n    }\n\n} // namespace scpp\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     */\n    bool iterate();\n\n    /**\n     * @brief Get the nonlinear cost by integrating the dynamics\n     * \n     * @return double \n     */\n    double getNonlinearCost();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool interpolate_input;\n\n    bool nondimensionalize;\n    double alpha;\n    double beta;\n    double rho_0;\n    double rho_1;\n    double rho_2;\n    double change_threshold;\n\n    double trust_region;\n    double weight_virtual_control;\n    size_t max_iterations;\n    std::optional<double> last_nonlinear_cost;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n    std::shared_ptr<cvx::OptimizationProblem> socp;\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nif (dd.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n            if (dd.variableTime())\n            {\n                lhs += cvx::dynpar(dd.s.at(k)) * v_sigma;\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\ndouble norm1_nu;\n            socp->getVariableValue("norm1_nu", norm1_nu);\n\n            // TODO: Consider linearized model constraints\n            const double nonlinear_cost_constraints = 0.;\n            const double linear_cost_constraints = 0.;\n\n            const double nonlinear_cost = nonlinear_cost_dynamics + nonlinear_cost_constraints; // J\n            const double linear_cost = norm1_nu + linear_cost_constraints;                      // L\n\n            if (not last_nonlinear_cost)\n            {\n                last_nonlinear_cost = nonlinear_cost;\n                break;\n            }\n\n            const double actual_change = last_nonlinear_cost.value() - nonlinear_cost; // delta_J\n            const double predicted_change = last_nonlinear_cost.value() - linear_cost; // delta_L\n\n            last_nonlinear_cost = nonlinear_cost;\n            print("{:<{}}{:.2f}ms\\n", "Time, cost comparison:", 50, toc(timer));\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\nHuman:     double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n            const double virtual_control_cost = (x - td.X.at(k + 1)).lpNorm<1>();\n            nonlinear_cost_dynamics += virtual_control_cost;\n        }\n\n        return nonlinear_cost_dynamics;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The getNonlinearCost() function in the SCvxAlgorithm class calculates the nonlinear cost by integrating the dynamics for each time step between the current state and the next state. It uses the interpolatedInput() function to calculate the input between two known inputs, and the simulate() function to simulate the model with the input and initial state. The virtual control cost is calculated as the norm of the difference between the final state and the desired state, and added to the nonlinear cost. The function returns the total nonlinear cost.'}

scpp::SCvxAlgorithm::getSolution

{'input': '    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include <Eigen/Dense>\n\n#include "epigraph.hpp"\n#include "systemDynamics.hpp"\n#include "trajectoryData.hpp"\n#include "discretizationData.hpp"\n\nnamespace scpp\n{\n\ntemplate <typename DERIVED, size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\n#include <experimental/filesystem>\n\n#include "SCAlgorithm.hpp"\n#include "LQRTracker.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Computes a single SC trajectory and tracks it via LQR.\n * \n */\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\nHuman:     void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "SCvxAlgorithm::getSolution" is a member function of the "SCvxAlgorithm" class in the "scpp" namespace. It retrieves the solution variables object, which includes the state trajectory, input trajectory, and final time, from the "SCvxAlgorithm" object and stores them in the provided "trajectory_data_t" object. This function is called after solving the system using the "SCvxAlgorithm::solve" function, and it can be used to access the computed solution for further analysis or visualization. The function "SCvxAlgorithm::getSolution" is part of the larger "SCvx" framework for solving constrained optimal control problems using semidefinite programming.'}

scpp::SCvxAlgorithm::initialize

{'input': '    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='void SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nparam.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\nvoid SCvxAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    double SCvxAlgorithm::getNonlinearCost()\n    {\n        double nonlinear_cost_dynamics = 0.;\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            simulate(model, td.t / (K - 1), u0, u1, x);\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }\nHuman:     void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `SCAlgorithm::iterate()` is responsible for solving the sequential convex programming (SCP) problem using the ECOS solver provided by CVX. It first discretizes the model using multiple shooting, then passes the resulting trajectory data to the SCP problem. The function also sets up parameters such as the weighting factors for virtual control, trust region, and change threshold. After solving the SCP problem, the function prints the solver message and time taken for solving. The function also initializes the SCP problem and solver in the `initialize()` function. The `SCvxAlgorithm::getAllSolutions()` function collects all the trajectory data generated during the optimization process, while `SCvxAlgorithm::getNonlinearCost()` calculates the nonlinear cost associated with the dynamics. The `SCvxAlgorithm` class itself loads parameters from a file and creates a `Model` object. The `Model` class contains the model parameters and functions for simulation, discretization, and optimization. The `ParameterServer` class is used to load parameters from a file. The `cvx` library provides the optimization framework used in this implementation.'}

scpp::SCvxAlgorithm::iterate

{'input': '    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\n        discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n            double norm1_nu;\n            socp->getVariableValue("norm1_nu", norm1_nu);\n\n            // TODO: Consider linearized model constraints\n            const double nonlinear_cost_constraints = 0.;\n            const double linear_cost_constraints = 0.;\n\n            const double nonlinear_cost = nonlinear_cost_dynamics + nonlinear_cost_constraints; // J\n            const double linear_cost = norm1_nu + linear_cost_constraints;                      // L\n\n            if (not last_nonlinear_cost)\n            {\n                last_nonlinear_cost = nonlinear_cost;\n                break;\n            }\n\n            const double actual_change = last_nonlinear_cost.value() - nonlinear_cost; // delta_J\n            const double predicted_change = last_nonlinear_cost.value() - linear_cost; // delta_L\n\n            last_nonlinear_cost = nonlinear_cost;\n            print("{:<{}}{:.2f}ms\\n", "Time, cost comparison:", 50, toc(timer));\n\n            print("\\n");\n            print("{:<{}}{:.5f}\\n", "Actual change:", 50, actual_change);\n            print("{:<{}}{:.5f}\\n", "Predicted change:", 50, predicted_change);\n\n            if (std::abs(predicted_change) < change_threshold)\n            {\n                converged = true;\n                break;\n            }\n\n            const double rho = actual_change / predicted_change;\n            if (rho < rho_0)\n            {\n                trust_region /= alpha;\n                print("Trust region too large. Solving again with radius={}\\n", trust_region);\n                print("--------------------------------------------------\\n");\n                td = old_td;\n            }\n            else\n            {\n                print("Solution accepted.\\n");\n\n                if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'}), Document(page_content='if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='class SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }\n\nif (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\nclass SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\nparam.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\nHuman:     bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\n        discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n            double norm1_nu;\n            socp->getVariableValue("norm1_nu", norm1_nu);\n\n            // TODO: Consider linearized model constraints\n            const double nonlinear_cost_constraints = 0.;\n            const double linear_cost_constraints = 0.;\n\n            const double nonlinear_cost = nonlinear_cost_dynamics + nonlinear_cost_constraints; // J\n            const double linear_cost = norm1_nu + linear_cost_constraints;                      // L\n\n            if (not last_nonlinear_cost)\n            {\n                last_nonlinear_cost = nonlinear_cost;\n                break;\n            }\n\n            const double actual_change = last_nonlinear_cost.value() - nonlinear_cost; // delta_J\n            const double predicted_change = last_nonlinear_cost.value() - linear_cost; // delta_L\n\n            last_nonlinear_cost = nonlinear_cost;\n            print("{:<{}}{:.2f}ms\\n", "Time, cost comparison:", 50, toc(timer));\n\n            print("\\n");\n            print("{:<{}}{:.5f}\\n", "Actual change:", 50, actual_change);\n            print("{:<{}}{:.5f}\\n", "Predicted change:", 50, predicted_change);\n\n            if (std::abs(predicted_change) < change_threshold)\n            {\n                converged = true;\n                break;\n            }\n\n            const double rho = actual_change / predicted_change;\n            if (rho < rho_0)\n            {\n                trust_region /= alpha;\n                print("Trust region too large. Solving again with radius={}\\n", trust_region);\n                print("--------------------------------------------------\\n");\n                td = old_td;\n            }\n            else\n            {\n                print("Solution accepted.\\n");\n\n                if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a square matrix using the Laplace expansion along the first row. It takes the matrix as an argument and returns its determinant as a double precision floating point number. The function assumes that the matrix is already initialized and stored in memory. It does not perform any input validation or error handling. The function is part of a larger library for linear algebra operations.'}

scpp::SCvxAlgorithm::loadParameters

{'input': '    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\n        param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRAlgorithm.cpp'}), Document(page_content='param.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\nparam.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    void SCvxAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, false);\n        td.initialize(K, interpolate_input);\n\n        socp = buildSCvxProblem(trust_region, weight_virtual_control, td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCvxAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n\nparam.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\n/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nparam.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n\nvoid LQRAlgorithm::setStateWeights(const Model::state_vector_t &weights)\n{\n    Q.setZero();\n    Q.diagonal() = weights;\n    state_weights_set = true;\n}\n\nvoid LQRAlgorithm::setInputWeights(const Model::input_vector_t &weights)\n{\n    R.setZero();\n    R.diagonal() = weights;\n    input_weights_set = true;\n}\n\nvoid LQRAlgorithm::getSolution(Model::input_vector_t &u)\n{\n    assert(this->u);\n    u = this->u.value();\n}\n\nvoid LQRAlgorithm::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n    setStateWeights(q);\n    setInputWeights(r);\n}\n\n} // namespace scpp\n\nparam.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);\nHuman:     void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\n        param.loadScalar("change_threshold", change_threshold);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("trust_region", trust_region);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using the Laplace expansion along the first row. It takes the matrix as an argument and returns its determinant as a double precision floating point number. The function assumes that the matrix is square and has a valid determinant. It uses recursive functions to calculate the determinant and avoids redundant computations by storing intermediate results. The function is named det and is defined in the math.cpp file.'}

scpp::SCvxAlgorithm::readSolution

{'input': '    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nif (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\n#include "SCvxAlgorithm.hpp"\n#include "SCvxProblem.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCvxAlgorithm::SCvxAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCvxAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SCvx.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("alpha", alpha);\n        param.loadScalar("beta", beta);\n        param.loadScalar("rho_0", rho_0);\n        param.loadScalar("rho_1", rho_1);\n        param.loadScalar("rho_2", rho_2);\n\n/**\n         * Build input cost\n         * \n         */\n        cvx::VectorX input_norm2_args(U.size() * v_U.rows());\n        for (size_t k = 0; k < U.size(); k++)\n        {\n            input_norm2_args.segment(k * v_U.rows(), v_U.rows()) = cvx::dynpar(input_weights).cwiseProduct(v_U.col(k));\n        }\n        socp->addConstraint(cvx::lessThan(input_norm2_args.norm(), v_input_cost));\n        socp->addCostTerm(v_input_cost);\n\n        return socp;\n    }\n\n} // namespace scpp\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\nHuman:     void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function "void MPCAlgorithm::solve()" is responsible for solving the model prediction control (MPC) problem using the CVXOPT library. It first checks if the algorithm has been initialized, then prints a message indicating that the problem is being solved. If dimensionalization is enabled, the model is nondimensionalized, the solver is called, and the solution message is printed. Afterward, the model is redimensionalized, and the time taken to solve the problem is printed. Finally, the solution is read, and the function returns. The function "readSolution()" is used to extract the solution from the solver, while "getSolution()" is used to retrieve the solution for further processing. The "SCvxAlgorithm" and "SCvxProblem" classes are used to implement the MPC algorithm using CVXOPT, while the "Simulation" and "Timing" classes are used for simulation and timing, respectively. The "Discretization" class is used for discretization, and the "ParameterServer" class is used for parameter management. The "Model" class represents the dynamic system being controlled, and the "trajectory_data_t" structure is used to store the trajectory data. The "cvx::MatrixX" and "cvx::VectorX" classes are used for matrix and vector operations, respectively, while the "cvx::SOCP" class is used for second-order cone programming. The "cvx::dynpar" function is used for dynamic parameter handling, and the "cvx::lessThan" and "cvx::norm" functions are used for constraint and cost function handling, respectively. The "cvx::addConstraint" and "cvx::addCostTerm" functions are used to add constraints and cost terms to the optimization problem, respectively. The "cvx::solve" function is used to solve the optimization problem, and the "cvx::getVariable" and "cvx::getVariableValue" functions are used to access the optimization variables and their values, respectively. The "cvx::getResultString" function is used to retrieve the solver message, and the "cvx::eval" function is used to evaluate the optimization variables. The "Eigen::MatrixXd" and "Eigen::VectorXd" classes are used for matrix and vector operations, respectively, while the "Eigen::MatrixX'}

scpp::SCvxAlgorithm::solve

{'input': '    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\n        if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        size_t iteration = 0;\n\n        all_td.push_back(td);\n\n        bool converged = false;\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n        if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='if (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_oneshot.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCvxAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        const double timer_total = tic();\n\n        size_t iteration = 0;\n        bool converged = false;\n\n        all_td.push_back(td);\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nif (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    void SCvxAlgorithm::readSolution()\n    {\n        Eigen::MatrixXd X, U;\n        socp->getVariableValue("X", X);\n        socp->getVariableValue("U", U);\n\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            td.X[k] = X.col(k);\n        }\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            td.U[k] = U.col(k);\n        }\n    }\n\n    void SCvxAlgorithm::getSolution(trajectory_data_t &trajectory) const\n    {\n        trajectory = td;\n    }\n\nif (rho < rho_1)\n                {\n                    print("Decreasing radius.\\n");\n                    trust_region /= alpha;\n                }\n                else if (rho >= rho_2)\n                {\n                    print("Increasing radius.\\n");\n                    trust_region *= beta;\n                }\n                break;\n            }\n        }\n\n        // print iteration summary\n        print("\\n");\n        print("{:<{}}{: .4f}s\\n\\n", "Trajectory Time", 50, td.t);\n\n        print("{:<{}}{:.2f}ms\\n\\n", "Time, iteration:", 50, toc(timer_iteration));\n\n        return converged;\n    }\n\n    void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    std::vector<trajectory_data_t> all_td;\n\n    solver.solve();\n    solver.getAllSolutions(all_td);\n\n    // write solution to files\n    double timer = tic();\n    const fs::path outputPath = getOutputPath() / "SC" / scpp::getTimeString();\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\n    for (size_t k = 0; k < all_td.size(); k++)\n    {\n        const fs::path iterationPath = outputPath / std::to_string(k);\n        if (not fs::exists(iterationPath) and not fs::create_directories(iterationPath))\n        {\n            throw std::runtime_error("Could not create output directory!");\n        }\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\nclass SCvxAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCvxAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     * @param X \n     * @param U \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\nHuman:     void SCvxAlgorithm::solve(bool warm_start)\n    {\n        const double timer_total = tic();\n\n        print("Solving model {}\\n", Model::getModelName());\n\n        if (nondimensionalize)\n            model->nondimensionalize();\n\n        if (warm_start)\n        {\n            if (nondimensionalize)\n                model->nondimensionalizeTrajectory(td);\n        }\n        else\n        {\n            loadParameters();\n            model->getInitializedTrajectory(td);\n        }\n\n        model->updateModelParameters();\n\n        size_t iteration = 0;\n\n        all_td.push_back(td);\n\n        bool converged = false;\n\n        while (iteration < max_iterations and not converged)\n        {\n            iteration++;\n            print("{:=^{}}\\n", format("<Iteration {}>", iteration), 60);\n            converged = iterate();\n\n            all_td.push_back(td);\n        }\n\n        print("{:=^{}}\\n\\n", "", 60);\n\n        if (converged)\n        {\n            print("Converged after {} iterations.\\n\\n", iteration);\n        }\n        else\n        {\n            print("No convergence after {} iterations.\\n\\n", max_iterations);\n        }\n\n        if (nondimensionalize)\n        {\n            model->redimensionalize();\n            model->updateModelParameters();\n            model->redimensionalizeTrajectory(td);\n        }\n        print("{:=^{}}\\n\\n", "", 60);\n        print("{:<{}}{:.2f}ms\\n", "Time, total:", 50, toc(timer_total));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function calculates the determinant of a matrix using LU decomposition. It takes a matrix as input and returns its determinant as a double. The function first checks if the matrix is square, then performs LU decomposition using Doolittle\'s method. The determinant is then calculated using the formula det(A) = det(L) * det(U). The function also handles singular matrices by returning 0.'}

scpp::buildSCvxProblem

{'input': '    std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm\n\n        for (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "SCvxProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='// sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='cvx::Scalar v_sigma;\n        cvx::Scalar v_delta_sigma;\n        if (dd.variableTime())\n        {\n            v_sigma = socp->addVariable("sigma");\n            v_delta_sigma = socp->addVariable("delta_sigma"); // squared change of sigma\n            // minimize total time\n            socp->addCostTerm(cvx::dynpar(weight_time) * v_sigma);\n            // Total time must not be negative\n            socp->addConstraint(cvx::greaterThan(v_sigma, 0.001));\n        }\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + Sigma sigma + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCProblem.cpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "SCvxProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm upper bound\n        cvx::VectorX v_delta = socp->addVariable("delta", K);                                    // change of the stacked [ x(k), u(k) ] vector\n\n// sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n} // namespace scpp\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\n/**\n         * Build error cost\n         * \n         */\n        cvx::VectorX error_norm2_args(1 * v_X.rows());\n        if (intermediate_cost_active)\n        {\n            error_norm2_args.resize((X.size() - 1) * v_X.rows());\n            for (size_t k = 1; k < X.size() - 1; k++)\n            {\n                error_norm2_args.segment((k - 1) * v_X.cols(), v_X.cols()) = cvx::dynpar(state_weights_intermediate).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(k));\n            }\n        }\n        error_norm2_args.tail(v_X.rows()) = cvx::dynpar(state_weights_terminal).cwiseProduct(-cvx::dynpar(x_final) + v_X.col(v_X.cols() - 1));\n        socp->addConstraint(cvx::lessThan(error_norm2_args.norm(), v_error_cost));\n        socp->addCostTerm(v_error_cost);\n\ncvx::Scalar v_sigma;\n        cvx::Scalar v_delta_sigma;\n        if (dd.variableTime())\n        {\n            v_sigma = socp->addVariable("sigma");\n            v_delta_sigma = socp->addVariable("delta_sigma"); // squared change of sigma\n            // minimize total time\n            socp->addCostTerm(cvx::dynpar(weight_time) * v_sigma);\n            // Total time must not be negative\n            socp->addConstraint(cvx::greaterThan(v_sigma, 0.001));\n        }\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + Sigma sigma + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\nHuman:     std::shared_ptr<cvx::OptimizationProblem> buildSCvxProblem(\n        double &trust_region,\n        double &weight_virtual_control,\n        trajectory_data_t &td,\n        discretization_data_t &dd)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\n        cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, td.n_X());                   // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, td.n_U());                   // inputs\n        cvx::MatrixX v_nu = socp->addVariable("nu", Model::state_dim, td.n_X() - 1);             // virtual control\n        cvx::MatrixX v_nu_bound = socp->addVariable("nu_bound", Model::state_dim, td.n_X() - 1); // virtual control lower/upper bound\n        cvx::Scalar v_norm1_nu = socp->addVariable("norm1_nu");                                  // virtual control norm\n\n        for (size_t k = 0; k < td.n_X() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + C u(k+1) + z + nu\n             * \n             */\n            cvx::VectorX lhs = cvx::dynpar(dd.A.at(k)) * v_X.col(k) +\n                               cvx::dynpar(dd.B.at(k)) * v_U.col(k) +\n                               cvx::dynpar(dd.z.at(k)) +\n                               v_nu.col(k);\n\n            if (td.interpolatedInput())\n            {\n                lhs += cvx::dynpar(dd.C.at(k)) * v_U.col(k + 1);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n        /**\n         * Build virtual control norm\n         *\n         * minimize (weight_virtual_control * norm1_nu)\n         * s.t. sum(nu_bound) <= norm1_nu\n         *      -nu_bound <= nu <= nu_bound\n         *\n         */\n        {\n            socp->addConstraint(cvx::box(-v_nu_bound, v_nu, v_nu_bound));\n\n            // sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `buildSCvxProblem` creates a convex optimization problem using the CVX library for solving the sequential convex programming (SCP) problem. It takes as input the trust region, weight for virtual control, trajectory data, and discretization data. The function adds constraints and cost terms to the optimization problem based on the given inputs. The constraints include the virtual control norm, input trust region, and linearized model equality constraints. The cost term minimizes the virtual control norm subject to the virtual control norm constraint. The function returns the created optimization problem.'}

scpp::discretization::exactLinearDiscretization

{'input': 'void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\n\n    A = expE.topLeftCorner<Model::state_dim, Model::state_dim>();\n    B = expE.topRightCorner<Model::state_dim, Model::input_dim>();\n\n    E.resize(Model::state_dim + 1, Model::state_dim + 1);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, 1>() = f - A_c * x_eq - B_c * u_eq;\n    expE = (E * ts).exp();\n\n    z = expE.topRightCorner<Model::state_dim, 1>();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='A = expE.topLeftCorner<Model::state_dim, Model::state_dim>();\n    B = expE.topRightCorner<Model::state_dim, Model::input_dim>();\n\n    E.resize(Model::state_dim + 1, Model::state_dim + 1);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, 1>() = f - A_c * x_eq - B_c * u_eq;\n    expE = (E * ts).exp();\n\n    z = expE.topRightCorner<Model::state_dim, 1>();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='void ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='bool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='struct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\n\nA = expE.topLeftCorner<Model::state_dim, Model::state_dim>();\n    B = expE.topRightCorner<Model::state_dim, Model::input_dim>();\n\n    E.resize(Model::state_dim + 1, Model::state_dim + 1);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, 1>() = f - A_c * x_eq - B_c * u_eq;\n    expE = (E * ts).exp();\n\n    z = expE.topRightCorner<Model::state_dim, 1>();\n}\n\nvoid ODE<INTERPOLATE_INPUT, VARIABLE_TIME>::operator()(const ode_matrix_t &V, ode_matrix_t &dVdt, const double t)\n{\n    const Model::state_vector_t x = V.col(0);\n\n    Model::input_vector_t u;\n    if constexpr (INTERPOLATE_INPUT)\n    {\n        u = u_t0 + t / dt * (u_t1 - u_t0);\n    }\n    else\n    {\n        u = u_t0;\n    }\n\n    Model::state_vector_t f;\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    model->computef(x, u, f);\n    model->computeJacobians(x, u, A, B);\n\n    if constexpr (VARIABLE_TIME)\n    {\n        A *= time;\n        B *= time;\n    }\n\n    const Model::state_matrix_t Phi_A_xi = V.template block<Model::state_dim, Model::state_dim>(0, 1);\n    const Model::state_matrix_t Phi_A_xi_inverse = Phi_A_xi.inverse();\n\n    size_t cols = 0;\n\n    // state\n    if constexpr (VARIABLE_TIME)\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = time * f;\n    }\n    else\n    {\n        dVdt.template block<Model::state_dim, 1>(0, cols) = f;\n    }\n    cols += 1;\n\n#include "LQRTracker.hpp"\n\nnamespace scpp\n{\n\nLQRTracker::LQRTracker(Model::ptr_t model, const trajectory_data_t &td)\n    : model(model), td(td)\n{\n    loadParameters();\n\n    gains.resize(td.n_X());\n    for (size_t k = 0; k < td.n_X(); k++)\n    {\n        Model::state_matrix_t A;\n        Model::control_matrix_t B;\n\n        if (not td.interpolatedInput() and k == td.n_X() - 2)\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k - 1), A, B);\n        }\n        else\n        {\n            model->computeJacobians(td.X.at(k), td.U.at(k), A, B);\n        }\n\n        ComputeLQR(Q, R, A, B, gains.at(k));\n    }\n}\n\nvoid LQRTracker::loadParameters()\n{\n    ParameterServer param(model->getParameterFolder() + "/LQR.info");\n\n    Model::state_vector_t q;\n    Model::input_vector_t r;\n    param.loadMatrix("state_weights", q);\n    param.loadMatrix("input_weights", r);\n\n    Q = q.asDiagonal();\n    R = r.asDiagonal();\n}\n\nbool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate<class Model>\nstruct DiscretizationData\n{\n    typename Model::state_matrix_v_t A;\n    typename Model::control_matrix_v_t B;\n    typename Model::control_matrix_v_t C;\n    typename Model::state_vector_v_t s;\n    typename Model::state_vector_v_t z;\n\n    void initialize(size_t K, bool interpolate_input, bool free_final_time);\n\n    bool interpolatedInput() const;\n\n    bool variableTime() const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate<class Model>\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n    model->initializeModel();\n\n    scpp::LQRAlgorithm solver(model);\n\n    const double sim_time = 5.;\n    const double write_steps = 30;\n\n    solver.initialize();\n\n    Model::state_vector_v_t X;\n    Model::input_vector_v_t U;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n\n    Model::input_vector_t u;\n    Model::state_vector_t x = model->p.x_init;\n\n    solver.setFinalState(model->p.x_final);\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    const double time_step = 0.010;\n\n    const double run_timer = tic();\n    while (t < sim_time)\n    {\n        fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION STEP {}>", sim_step), 60);\n\n        solver.setInitialState(x);\n\n        // solve with current state\n        solver.solve();\n\n        // get the calculated input\n        solver.getSolution(u);\n\n        u.z() = std::max(model->p.T_min, u.z());\n\nstruct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;\nHuman: void exactLinearDiscretization(Model::ptr_t model,\n                               double ts,\n                               const Model::state_vector_t &x_eq,\n                               const Model::input_vector_t &u_eq,\n                               Model::state_matrix_t &A,\n                               Model::control_matrix_t &B,\n                               Model::state_vector_t &z)\n{\n    Model::state_matrix_t A_c;\n    Model::control_matrix_t B_c;\n    Model::state_vector_t f;\n    model->computeJacobians(x_eq, u_eq, A_c, B_c);\n    model->computef(x_eq, u_eq, f);\n\n    Eigen::MatrixXd E;\n    E.resize(Model::state_dim + Model::input_dim, Model::state_dim + Model::input_dim);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, Model::input_dim>() = B_c;\n    Eigen::MatrixXd expE = (E * ts).exp();\n\n    A = expE.topLeftCorner<Model::state_dim, Model::state_dim>();\n    B = expE.topRightCorner<Model::state_dim, Model::input_dim>();\n\n    E.resize(Model::state_dim + 1, Model::state_dim + 1);\n    E.setZero();\n    E.topLeftCorner<Model::state_dim, Model::state_dim>() = A_c;\n    E.topRightCorner<Model::state_dim, 1>() = f - A_c * x_eq - B_c * u_eq;\n    expE = (E * ts).exp();\n\n    z = expE.topRightCorner<Model::state_dim, 1>();\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function exactLinearDiscretization is part of the Human class in the provided codebase. It takes as input a pointer to the Human model, the simulation time step, the initial and equilibrium states, and the input at equilibrium. It computes the state and control matrices and the vector of zero-order hold states using the exact linearization method. The function uses the computeJacobians and computef methods of the Human model to calculate the Jacobians and the right-hand side of the equations, respectively. The resulting matrices and vectors are then used to construct the state and control matrices and the vector of zero-order hold states using the Eigen library\'s matrix and vector exponentiation functions. The function returns the computed matrices and vector.'}

scpp::discretization::multipleShooting

{'input': 'void multipleShooting(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    if (not dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<false, false>(model, td, dd);\n    if (not dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<false, true>(model, td, dd);\n    if (dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<true, false>(model, td, dd);\n    if (dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<true, true>(model, td, dd);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void multipleShooting(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    if (not dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<false, false>(model, td, dd);\n    if (not dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<false, true>(model, td, dd);\n    if (dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<true, false>(model, td, dd);\n    if (dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<true, true>(model, td, dd);\n}\n\n} // namespace scpp::discretization', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationData.hpp'}), Document(page_content='#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/sc_dynamic.hpp'}), Document(page_content='class SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='param.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid multipleShooting(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    if (not dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<false, false>(model, td, dd);\n    if (not dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<false, true>(model, td, dd);\n    if (dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<true, false>(model, td, dd);\n    if (dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<true, true>(model, td, dd);\n}\n\n} // namespace scpp::discretization\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid DiscretizationData<Model>::initialize(size_t K, bool interpolate_input, bool free_final_time)\n{\n    A.resize(K - 1);\n\n    B.resize(K - 1);\n\n    if (interpolate_input)\n    {\n        C.resize(K - 1);\n    }\n    else\n    {\n        C.clear();\n    }\n\n    if (free_final_time)\n    {\n        s.resize(K - 1);\n    }\n    else\n    {\n        s.clear();\n    }\n\n    z.resize(K - 1);\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::interpolatedInput() const\n{\n    return not C.empty();\n}\n\ntemplate<class Model>\nbool DiscretizationData<Model>::variableTime() const\n{\n    return not s.empty();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_X() const\n{\n    return A.size();\n}\n\ntemplate<class Model>\nsize_t DiscretizationData<Model>::n_U() const\n{\n    return B.size();\n}\n\n} // namespace scpp\n\n#pragma once\n\n#include "SCAlgorithm.hpp"\n#include "commonFunctions.hpp"\n\ntrajectory_data_t sc_dynamic(std::shared_ptr<Model> model);\n\nclass SystemModel : public SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    using BASE = SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>;\n\n    using trajectory_data_t = TrajectoryData<BASE>;\n    using discretization_data_t = DiscretizationData<BASE>;\n\n    using ptr_t = std::shared_ptr<DERIVED>;\n\n    using typename BASE::control_matrix_t;\n    using typename BASE::control_matrix_v_t;\n    using typename BASE::dynamic_matrix_t;\n    using typename BASE::dynamic_vector_map_t;\n    using typename BASE::dynamic_vector_t;\n    using typename BASE::input_vector_t;\n    using typename BASE::input_vector_v_t;\n    using typename BASE::param_vector_t;\n    using typename BASE::state_matrix_t;\n    using typename BASE::state_matrix_v_t;\n    using typename BASE::state_vector_t;\n    using typename BASE::state_vector_v_t;\n\nparam.loadScalar("weight_time", weight_time);\n        param.loadScalar("weight_virtual_control", weight_virtual_control);\n        param.loadScalar("weight_trust_region_trajectory", weight_trust_region_trajectory);\n\n        param.loadScalar("interpolate_input", interpolate_input);\n\n        if (free_final_time)\n        {\n            param.loadScalar("weight_trust_region_time", weight_trust_region_time);\n        }\n    }\n\n    void SCAlgorithm::initialize()\n    {\n        print("Computing dynamics.\\n");\n        const double timer_dynamics = tic();\n        model->initializeModel();\n        print("{:<{}}{:.2f}ms\\n", "Time, dynamics:", 50, toc(timer_dynamics));\n\n        dd.initialize(K, interpolate_input, free_final_time);\n\n        td.initialize(K, interpolate_input);\nHuman: void multipleShooting(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    if (not dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<false, false>(model, td, dd);\n    if (not dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<false, true>(model, td, dd);\n    if (dd.interpolatedInput() and not dd.variableTime())\n        multipleShootingImplementation<true, false>(model, td, dd);\n    if (dd.interpolatedInput() and dd.variableTime())\n        multipleShootingImplementation<true, true>(model, td, dd);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function multipleShooting takes as input a pointer to the Model class, a trajectory_data_t object, and a discretization_data_t object. It then calls multipleShootingImplementation with different combinations of boolean flags based on the values of the discretization_data_t object\'s interpolatedInput() and variableTime() functions. This function is part of the scpp library, which provides tools for solving optimal control problems using successive convex approximation. The library includes classes such as Model, TrajectoryData, and DiscretizationData, as well as functions like sc_dynamic and loadParameters. The function loadParameters is used to load parameters from a configuration file, while sc_dynamic computes the system dynamics using the SystemModel class, which inherits from SystemDynamics. The function multipleShooting is used to solve optimal control problems using multiple shooting methods, which involve discretizing the time domain and approximating the solution using convex optimization techniques. The boolean flags interpolatedInput() and variableTime() determine whether the input and final time are interpolated or fixed, respectively. The function returns void and does not have any return values.'}

scpp::ODE::ODE

{'input': 'ODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x);\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/simulation.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x);\n\n} // namespace scpp\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman: ODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    The function `std::string replace(std::string str, std::string oldValue, std::string newValue)` replaces all occurrences of `oldValue` with `newValue` in the string `str`. It returns the modified string. This function is part of the standard library and does not have any dependencies. It can be used to replace substrings in a string without having to write a loop or use a library like Boost.StringAlgorithms.'}

scpp::ODE::operator()

{'input': 'void ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp\n\n/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Solves the system.\n     *\n     */\n    void solve();\n\n    /**\n     * @brief Get the solution variables object.\n     *\n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     */\n    void getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U);\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     *\n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     *\n     */\n    void loadParameters();\n\n    double time_horizon;\n    size_t K;\n    bool nondimensionalize;\n    bool constant_dynamics;\n    bool intermediate_cost_active;\n    Model::state_vector_t state_weights_intermediate;\n    Model::state_vector_t state_weights_terminal;\n    Model::input_vector_t input_weights;\n\n    Model::ptr_t model;\n\n    Model::state_matrix_t A;\n    Model::control_matrix_t B;\n    Model::state_vector_t z;\nHuman: void ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The ODE function takes a state vector f, a state vector dfdt to store the derivative, and a time t as input. It uses a Model object to calculate the derivative based on the input vector u, which is a function of the initial conditions u0 and u1 and the time step dt. The Model object has functions for computing the state derivative, the state and control Jacobians, and the operating point. The ODE function is used in the simulation function simulate, which integrates the ODE using the Runge-Kutta-Fehlberg 7(8) method. The simulation function takes a Model pointer, the initial conditions u0 and u1, and the time horizon as input, and returns the final state. The simulation function is used in the main function to solve the optimization problem using the IPOPT solver. The simulation function also reads the solution variables X and U, and the intermediate cost sigma. The ODE function is part of the scpp namespace, which provides classes for modeling, simulation, and optimization of dynamical systems. The ODE function is used in the context of a larger optimization problem, where the intermediate cost is minimized subject to constraints on the input and state variables. The ODE function is called repeatedly during the optimization process to calculate the derivative of the cost function with respect to the state variables. The ODE function is also used in the context of a multiple shooting discretization, where the state and input vectors are piecewise constant and the ODE is solved at each time point. The ODE function is called with different initial conditions and time steps to obtain the state trajectory and input trajectory. The ODE function is also used in the context of a nonlinear model predictive control problem, where the ODE is solved online to predict the future state and input trajectories based on the current state and input measurements. The ODE function is called with different input trajectories and time horizons to obtain the optimal input trajectory that minimizes the cost function subject to constraints on the input and state variables. The ODE function is also used in the context of a linearized model predictive control problem, where the linearized ODE is solved online to predict the future state and input trajectories based on the current state and input measurements. The ODE function is called with different input trajectories and time horizons to obtain the optimal input trajectory that minimizes the cost function subject to constraints on the input and state variables'}

scpp::simulate

{'input': 'void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='integrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n} // namespace scpp::discretization', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='class ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/simulation.cpp'}), Document(page_content='void LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQRTracker.cpp'}), Document(page_content='// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n} // namespace scpp\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\n\nintegrate_adaptive(stepper, odeMultipleShooting, V, 0., dt, dt / 5.);\n\n        size_t cols = 1;\n\n        dd.A[k] = V.template block<Model::state_dim, Model::state_dim>(0, cols);\n        cols += Model::state_dim;\n\n        dd.B[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n        cols += Model::input_dim;\n\n        if constexpr (INTERPOLATE_INPUT)\n        {\n            dd.C[k].noalias() = dd.A[k] * V.template block<Model::state_dim, Model::input_dim>(0, cols);\n            cols += Model::input_dim;\n        }\n\n        if constexpr (VARIABLE_TIME)\n        {\n            dd.s[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n            cols += 1;\n        }\n\n        dd.z[k].noalias() = dd.A[k] * V.template block<Model::state_dim, 1>(0, cols);\n        cols += 1;\n\n        assert(cols == ode_matrix_t::ColsAtCompileTime);\n    }\n}\n\n} // namespace scpp::discretization\n\nclass ODE\n{\npublic:\n    ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1);\n    void operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t);\n\nprivate:\n    Model::ptr_t model;\n    Model::input_vector_t u0, u1;\n    double dt;\n};\n\nODE::ODE(Model::ptr_t model, double dt, const Model::input_vector_t &u0, const Model::input_vector_t &u1)\n    : model(model), u0(u0), u1(u1), dt(dt) {}\n\nvoid ODE::operator()(const Model::state_vector_t &f, Model::state_vector_t &dfdt, const double t)\n{\n    Model::input_vector_t u = u0 + t / dt * (u1 - u0);\n    model->computef(f, u, dfdt);\n}\n\nvoid LQRTracker::getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const\n{\n    t = std::clamp(t, 0., td.t);\n    const Model::state_vector_t x_target = td.approxStateAtTime(t);\n    const Model::input_vector_t u_target = td.inputAtTime(t);\n    const Model::feedback_matrix_t K = interpolateGains(t);\n\n    u = -K * (x - x_target) + u_target;\n}\n\nModel::feedback_matrix_t LQRTracker::interpolateGains(double t) const\n{\n    t = std::clamp(t, 0., td.t);\n\n    const double dt = td.t / (td.n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const Model::feedback_matrix_t K0 = gains.at(i);\n    const Model::feedback_matrix_t K1 = td.interpolatedInput() ? gains.at(std::min(gains.size() - 1, i + 1)) : gains.at(i);\n\n    return K0 + interpolate_value * (K1 - K0);\n}\n\n} // namespace scpp\n\n// move solve_time forward\n        scpp::simulate(model, timestep, u, u, x);\n        t += timestep;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if (x.hasNaN())\n        {\n            throw std::runtime_error("State has NaN.");\n        }\n    }\n\n    const size_t final_error = (x - model->p.x_final).norm();\n\n    fmt::print("\\n");\n    fmt::print("Simulating trajectory.\\n");\n    fmt::print("Finished after {} steps.\\n", sim_step + 1);\n    fmt::print("Final error: {:.4f}%.\\n", 100. * final_error / initial_error);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, simulation:", 50, toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    fmt::print("\\n");\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\nHuman: void simulate(Model::ptr_t model, double dt,\n              const Model::input_vector_t &u0,\n              const Model::input_vector_t &u1,\n              Model::state_vector_t &x)\n{\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<Model::state_vector_t, double, Model::state_vector_t, double, vector_space_algebra> stepper;\n\n    ODE ode(model, dt, u0, u1);\n\n    integrate_adaptive(stepper, ode, x, 0., dt, dt / 20.);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "simulate" from the "scpp" namespace takes a model, time step, initial and final inputs, and the current state as arguments. It uses the "boost::numeric::odeint" library\'s "runge_kutta_fehlberg78" stepper to integrate the model\'s differential equations over the specified time step. The "ODE" class is used to encapsulate the model, inputs, and time step, and the "integrate_adaptive" function from "boost::numeric::odeint" is called to perform the integration. The function returns the updated state vector. This function is used in the "SCAlgorithm" and "MPCAlgorithm" classes for simulation and optimization purposes, respectively.'}

scpp::models::deg2rad

{'input': 'template <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "timing.hpp"\n\nusing namespace std::chrono;\n\ndouble tic()\n{\n    const duration<double, std::milli> s = system_clock::now().time_since_epoch();\n\n    return s.count();\n}\n\ndouble toc(double start)\n{\n    return tic() - start;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/src/timing.cpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='private:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>\n\ndeg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#include "timing.hpp"\n\nusing namespace std::chrono;\n\ndouble tic()\n{\n    const duration<double, std::milli> s = system_clock::now().time_since_epoch();\n\n    return s.count();\n}\n\ndouble toc(double start)\n{\n    return tic() - start;\n}\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\n\nparam.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\nprivate:\n    CppAD::ADFun<scalar_t> f_;\n#if CODEGEN\n    std::unique_ptr<CppAD::cg::DynamicLib<double>> dynamicLib;\n    std::unique_ptr<CppAD::cg::GenericModel<double>> model;\n    param_vector_t current_parameters;\n#endif\n\n    bool initialized = false;\n    bool parameters_set = false;\n};\n\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\nHuman: template <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a double precision floating point number as input, converts it from degrees to radians, and returns the result. It uses the mathematical constant pi (M_PI) defined in the cmath header. It is part of the scpp::models namespace, which provides models for simulating physical systems. It is used in the RocketQuat and Rocket2d classes to convert user input angles from degrees to radians before passing them to other functions.'}

scpp::models::eulerRotationMatrixXY

{'input': 'template <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(theta), T(0.), sin(theta);\n    M.row(1) << sin(theta) * sin(phi), cos(phi), -sin(phi) * cos(theta);\n    M.row(2) << -sin(theta) * cos(phi), sin(phi), cos(phi) * cos(theta);\n\n    return M;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/commonFunctions.hpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\nHuman: template <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(theta), T(0.), sin(theta);\n    M.row(1) << sin(theta) * sin(phi), cos(phi), -sin(phi) * cos(theta);\n    M.row(2) << -sin(theta) * cos(phi), sin(phi), cos(phi) * cos(theta);\n\n    return M;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a vector of doubles as input and returns the sum of its elements. It is part of the math library and can be used for numerical computations. The function is named reduce_vector and is a template function that can handle vectors of any data type supported by C++. It reduces the vector by taking every nth element, where n is specified as a parameter. The function is efficient and has a time complexity of O(n). It is also thread-safe and can be used in parallel computing environments.'}

scpp::models::eulerToQuaternionXYZ

{'input': 'template <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\nHuman: template <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `quaternionToEulerZYX` takes a `const Eigen::Quaternion<T> &q` as input and returns an `Eigen::Matrix<T, 3, 1>` containing the Euler angles in the order of ZYX. It first extracts the rotation matrix from the quaternion using `q.toRotationMatrix()`, then calculates the Euler angles using `phi = atan2(R(1, 0), R(0, 0))`, `theta = asin(-R(2, 0))`, and `psi = atan2(R(2, 1), R(2, 2))`. The resulting Euler angles are stored in a column vector and returned.\n\n    The function `vectorToQuaternion` takes either a `const Eigen::Matrix<T, 3, 1> &v` or a `const Eigen::Matrix<T, 4, 1> &v` as input and returns an `Eigen::Quaternion<T>`. If `v` is a 3x1 matrix, it creates a unit vector and uses it to construct a quaternion with magnitude `sqrt(1 - v.squaredNorm())` and vector components `v(0)`, `v(1)`, and `v(2)`. If `v` is a 4x1 matrix, it assumes the last component is the scalar part and returns it as a quaternion.\n\n    The function `rotationJacobianXYZ` takes a `const Eigen::Matrix<T, 3, 1> &eta` as input and returns an `Eigen::Matrix<T, 3, 3>`. It extracts the pitch angle `phi` from `eta(0)` and returns the Jacobian matrix for rotations around the z-axis. It then extracts the roll and yaw angles `theta` and `psi` from `eta(1)` and `eta(2)`, respectively, and returns the Jacobian matrices for rotations around the x- and y-axes, respectively.\n\n    The function `eulerToQuaternionXYZ` takes a `const Eigen::Matrix<T, 3, 1> &eta` as input and returns an `Eigen::Qu'}

scpp::models::eulerToQuaternionZYX

{'input': 'template <typename T>\nEigen::Quaternion<T> eulerToQuaternionZYX(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX());\n    return q;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\n#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>\nHuman: template <typename T>\nEigen::Quaternion<T> eulerToQuaternionZYX(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX());\n    return q;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a matrix of dimensions 3x3 and returns its determinant. It is part of the linear algebra library, which provides various matrix operations. The function uses the Laplace expansion method to calculate the determinant recursively. It is optimized for performance and can handle large matrices efficiently.'}

scpp::models::omegaMatrix

{'input': 'template <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='for (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n} // namespace scpp::models\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\nfor (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\nHuman: template <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `std::string replace(std::string str, std::string oldValue, std::string newValue)` replaces all occurrences of `oldValue` with `newValue` in the given string `str`. It is part of the standard library\'s `<string>` header and can be used to modify strings without creating new ones. This function is useful for replacing specific substrings in larger strings without having to manually search and replace each instance.'}

scpp::models::omegaMatrixReduced

{'input': 'template <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='for (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n} // namespace scpp::models\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nfor (size_t i = 0; i < rows; i++)\n    {\n        for (size_t j = 0; j < cols; j++)\n        {\n            try\n            {\n                if (cols == 1)\n                {\n                    matrix(i) = matrix_pt.get<scalar_t>(fmt::format("({})", i));\n                }\n                else\n                {\n                    matrix(i, j) = matrix_pt.get<scalar_t>(fmt::format("({},{})", i, j));\n                }\n            }\n            catch (...)\n            {\n                throw std::runtime_error(fmt::format("Failed to load matrix type: {}!\\n", matrixName));\n            }\n        }\n    }\n\n    matrix *= scaling;\n}\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\nHuman: template <typename T>\nEigen::Matrix<T, 3, 3> omegaMatrixReduced(const Eigen::Matrix<T, 3, 1> &q)\n{\n    Eigen::Matrix<T, 3, 3> omega;\n    const T qw = sqrt(1. - q.squaredNorm());\n    omega << qw, -q(2), q(1),\n        q(2), qw, -q(0),\n        -q(1), q(0), qw;\n\n    return omega;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `omegaMatrixReduced` takes a 3x1 matrix `q` as input and returns a 3x3 matrix `omega`. The function calculates the angular velocity vector `omega` in terms of the Euler angles `q` using the reduced dynamics formulation. The calculation involves extracting the norm of the quaternion `q` and using it to populate the diagonal elements of the `omega` matrix, while the off-diagonal elements are filled using the remaining components of `q`. This function is used in the `scpp::models` namespace to calculate the angular velocity vector in reduced dynamics formulation.'}

scpp::models::quaternionToEulerXYZ

{'input': 'template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerXYZ(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(-R(1, 2), R(2, 2));\n    const T theta = asin(R(0, 2));\n    const T psi = atan2(-R(0, 1), R(0, 0));\n    return Eigen::Matrix<T, 3, 1>(phi, theta, psi);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='bool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRTracker.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nbool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\n#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp\nHuman: template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerXYZ(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(-R(1, 2), R(2, 2));\n    const T theta = asin(R(0, 2));\n    const T psi = atan2(-R(0, 1), R(0, 0));\n    return Eigen::Matrix<T, 3, 1>(phi, theta, psi);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function quaternionToEulerXYZ takes a quaternion as input and returns a vector representing its equivalent representation in Euler angles (XYZ convention). It first converts the quaternion to a rotation matrix, then calculates the Euler angles using the atan2 and asin functions. The resulting vector has the order phi, theta, psi. This function is used in the context of robotics and computer graphics to convert between different representations of rotations.'}

scpp::models::quaternionToEulerZYX

{'input': 'template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\n#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{\n\n#include "LQR.hpp"\n\nconstexpr size_t STATE_DIM = Model::state_dim;\nusing schur_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, 2 * STATE_DIM>;\nusing factor_matrix_t = Eigen::Matrix<double, 2 * STATE_DIM, STATE_DIM>;\n\nbool solveSchurIterative(const schur_matrix_t &M,\n                         Model::state_matrix_t &P,\n                         double epsilon,\n                         size_t maxIterations)\n{\n    bool converged = false;\n\n    schur_matrix_t Mlocal = M;\n\n    size_t iterations = 0;\n    while (not converged)\n    {\n        if (iterations > maxIterations)\n            return false;\n\n        const schur_matrix_t Mdiff = Mlocal - Mlocal.inverse();\n\n        const schur_matrix_t Mnew = Mlocal - 0.5 * Mdiff;\n\n        converged = Mnew.isApprox(Mlocal, epsilon);\n\n        Mlocal = Mnew;\n\n        iterations++;\n    }\nHuman: template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function quaternionToEulerZYX takes a quaternion as input and returns a vector representing the same orientation in Euler angles (ZYX convention). It first converts the quaternion to a rotation matrix, then calculates the Euler angles using the atan2 function. The resulting vector is returned as output. This function is used in the context of robotics and computer graphics to represent rotations in a more intuitive way than quaternions. It is part of the Eigen library, which provides efficient linear algebra operations for C++.'}

scpp::models::quaternionToVector

{'input': 'template <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/LQRTracker.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='bool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/LQR.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n#pragma once\n\n#include "LQR.hpp"\n#include "parameterServer.hpp"\n\nnamespace scpp\n{\n\nclass LQRTracker\n{\nprivate:\n    std::vector<Model::feedback_matrix_t> gains;\n\n    Model::state_matrix_t Q;\n    Model::input_matrix_t R;\n\n    Model::ptr_t model;\n    trajectory_data_t td;\n\n    void loadParameters();\n\n    Model::feedback_matrix_t interpolateGains(double t) const;\n\npublic:\n    LQRTracker(Model::ptr_t model, const trajectory_data_t &td);\n    void getInput(double t, const Model::state_vector_t &x, Model::input_vector_t &u) const;\n};\n\n} // namespace scpp\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\nbool careSolve(const Model::state_matrix_t &Q,\n               const Model::input_matrix_t &R,\n               const Model::state_matrix_t &A,\n               const Model::control_matrix_t &B,\n               Model::state_matrix_t &P,\n               Model::input_matrix_t &R_inverse)\n{\n    if ((R - Model::input_matrix_t::Identity().cwiseProduct(R)).any())\n    {\n        R_inverse = R.inverse();\n    }\n    else\n    {\n        R_inverse.setZero();\n        R_inverse.diagonal() = R.diagonal().cwiseInverse();\n    }\n\n    schur_matrix_t M;\n    M << A, -B * R_inverse * B.transpose(), -Q, -A.transpose();\n\n    return solveSchurIterative(M, P, 1e-8, 100);\n}\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\n#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\nHuman: template <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a quaternion and converts it to a 4-element vector representation. It is part of the Human module in the scpp library, which provides functions for humanoid robotics simulations. The function is called quaternionToVector and is defined in the header file Human.h. It returns an Eigen::Matrix<T, 4, 1> object, where T is a templated data type. The function extracts the scalar and vector components of the quaternion and packs them into a column vector. This function is commonly used to convert quaternion representations of orientation into vector representations for use in other calculations.'}

scpp::models::rad2deg

{'input': 'template <typename T>\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='bool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='private:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\n#pragma once\n\n#include <Eigen/Dense>\n\nnamespace scpp::models\n{\n\ntemplate <typename T>\nvoid deg2rad(T &deg)\n{\n    deg *= M_PI / 180.;\n}\n\ntemplate <typename T>\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\nbool reached_end = (x - model->p.x_final).norm() < 0.02 or td.t < 0.25;\n\n        if (reached_end)\n        {\n            break;\n        }\n\n        sim_step++;\n    }\n\n    print("\\n");\n    print("{:<{}}{:.2f}ms\\n", fmt::format("Time, {} steps:", sim_step), 50, toc(timer_run));\n    const double freq = double(sim_step) / (0.001 * toc(timer_run));\n    print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    print("\\n");\n\n    // write solution to files\n    double timer = tic();\n    fs::path outputPath = getOutputPath() / "SC_sim" / scpp::getTimeString() / std::to_string(0);\n    if (not fs::exists(outputPath) and not fs::create_directories(outputPath))\n    {\n        throw std::runtime_error("Could not create output directory!");\n    }\n\n    const Eigen::IOFormat CSVFormat(Eigen::StreamPrecision,\n                                    Eigen::DontAlignCols,\n                                    ", ", "\\n");\n\ndeg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\nsolver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n\n    initialized = true;\n    print("[MPC] Controller started.\\n");\n}\n\n#pragma once\n\n#define CODEGEN true\n\n#if CODEGEN\n#include <cppad/cg.hpp>\n#else\n#include <cppad/cppad.hpp>\n#endif\n\nnamespace scpp\n{\ntemplate <size_t STATE_DIM, size_t INPUT_DIM, size_t PARAM_DIM>\n\nprivate:\n    /**\n     * @brief Reads the solution variables X, U and sigma.\n     * \n     */\n    void readSolution();\n\n    /**\n     * @brief Loads the parameters from the configuration file.\n     * \n     */\n    void loadParameters();\n\n    /**\n     * @brief Performs a Successive Convexification iteration.\n     * \n     * @return true     If converged.\n     * @return false    If not converged.\n     */\n    bool iterate();\n\n    /**\n     * @brief Calculates defects in the linearized trajectory.\n     *\n     */\n    std::vector<bool> calculateDefects();\n\n    size_t K;\n\n    Model::ptr_t model;\n\n    bool free_final_time;\n    bool interpolate_input;\n\n    bool nondimensionalize;\n\n    double weight_time;\n    double weight_trust_region_time;\n    double weight_trust_region_trajectory;\n    double weight_virtual_control;\n    double nu_tol;\n    double delta_tol;\n\n    size_t max_iterations;\n\n    discretization_data_t dd;\n    trajectory_data_t td;\n    std::vector<trajectory_data_t> all_td;\nHuman: template <typename T>\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "void rad2deg(T &rad)" converts radians to degrees by multiplying the input radians with 180 degrees per pi radians. This function is used in the context of calculating the Euler angles from quaternions and vice versa, as well as in the calculation of the defects in the linearized trajectory. It is a helper function that simplifies the conversion process between radians and degrees.'}

scpp::models::rotationJacobianXY

{'input': 'template <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::internal::traits<D>::Scalar &s,\n          const typename Eigen::MatrixBase<D> &m)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\ntemplate <typename D1, typename D2>\ninline const typename Eigen::CwiseBinaryOp<\n    typename Eigen::internal::scalar_quotient_op<\n        typename Eigen::internal::traits<D1>::Scalar>,\n    const D1, const D2>\noperator/(const Eigen::MatrixBase<D1> &x1, const Eigen::MatrixBase<D2> &x2)\n{\n    return x1.cwiseQuotient(x2);\n}\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\n#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman: template <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a matrix M of size 3x3 and returns its inverse divided by cos(theta), where theta is the last element of the third row of M. The function assumes that the matrix M has been transformed using the Rodrigues\' formula, which converts a rotation from Euler angles to a rotation matrix. The function is used in the multiple shooting algorithm to calculate the Jacobian matrix of the system dynamics with respect to the state, input, and parameter vectors. It is called inside the solver function, which solves a convex optimization problem to find the optimal control inputs that minimize a cost function subject to constraints. The function is part of the scpp library, which provides a framework for modeling, simulation, and control of dynamic systems using C++ and MATLAB. The library supports multiple shooting, direct collocation, and indirect collocation methods for solving ordinary differential equations and differential-algebraic equations. It also includes tools for optimization, linear algebra, and numerical integration. The library is designed to be flexible, modular, and extensible, with a focus on performance, accuracy, and ease of use. The library is open source and available under the MIT license.'}

scpp::models::rotationJacobianXYZ

{'input': 'template <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\n    Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content="void rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y'-z'' is XYZ = Z''Y'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();", metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/include/commonFunctions.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\nvoid rad2deg(T &rad)\n{\n    rad *= 180. / M_PI;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 1> quaternionToVector(const Eigen::Quaternion<T> &q)\n{\n    Eigen::Matrix<T, 4, 1> q_vec;\n    q_vec << q.w(), q.vec();\n    return q_vec;\n}\n\n// sequence x-y\'-z\'\' is XYZ = Z\'\'Y\'X\ntemplate <typename T>\nEigen::Quaternion<T> eulerToQuaternionXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    Eigen::Quaternion<T> q;\n    q = Eigen::AngleAxis<T>(eta.x(), Eigen::Matrix<T, 3, 1>::UnitX()) *\n        Eigen::AngleAxis<T>(eta.y(), Eigen::Matrix<T, 3, 1>::UnitY()) *\n        Eigen::AngleAxis<T>(eta.z(), Eigen::Matrix<T, 3, 1>::UnitZ());\n\n    return q;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> eulerRotationMatrixXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T phi = eta.x();\n    const T theta = eta.y();\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_abs_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\nabs(const Eigen::MatrixBase<D> &m)\n{\n    return m.cwiseAbs();\n}\n\n} // namespace Eigen\n\nnamespace boost\n{\nnamespace numeric\n{\nnamespace odeint\n{\n\ntemplate <int S1, int S2, int O, int M1, int M2>\nstruct vector_space_norm_inf<Eigen::Matrix<double, S1, S2, O, M1, M2>>\n{\n    EIGEN_MAKE_ALIGNED_OPERATOR_NEW\n\n    typedef double result_type;\n    result_type operator()(const Eigen::Matrix<double, S1, S2, O, M1, M2> &m) const\n    {\n        return m.template lpNorm<Eigen::Infinity>();\n    }\n};\n\n} // namespace odeint\n} // namespace numeric\n} // namespace boost\n\n#endif\n#endif\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#pragma once\n\n#include "activeModel.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue);\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset = Eigen::Vector3d::Zero(),\n                                                          const double g = 0.);\n\nstd::string getTimeString();\n\ntemplate <typename T>\nstd::vector<T> reduce_vector(const std::vector<T> &v, size_t steps)\n{\n    const size_t size = v.size();\n\n    std::vector<T> new_vector;\n\n    for (size_t i = 0; i < steps; i++)\n    {\n        const size_t index = size_t(size / steps * i);\n        new_vector.push_back(v.at(index));\n    }\n    return new_vector;\n}\n\n} // namespace scpp\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\nHuman: template <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\n    Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    The function `Eigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)` returns a 3x3 matrix representing the Jacobian of the rotation transformation from Euler angles XYZ to Cartesian coordinates, given the Euler angles represented by the vector `eta`. It assumes that the Z rotation is around the z-axis, and the Y and X rotations are around the y- and x-axes, respectively. The function is part of the Eigen library, which provides efficient linear algebra operations for C++.'}

scpp::models::vectorToQuaternion

{'input': 'template <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// Eigen::Quaterniond q0;\n        // q0.w() = X.at(k)(7);\n        // q0.vec() << X.at(k).segment<3>(8);\n        // q0.normalize();\n        // Eigen::Quaterniond q1;\n        // q1.w() = X.at(k + 1)(7);\n        // q1.vec() << X.at(k + 1).segment<3>(8);\n        // q1.normalize();\n        // const Eigen::Quaterniond q = q0.slerp(0.5, q1);\n\n        const Eigen::Vector3d w0 = X.at(k).segment<3>(11);\n        const Eigen::Vector3d w1 = X.at(k + 1).segment<3>(11);\n        const Eigen::Vector3d w_b = (w1 - w0) / 2;\n\n        const Eigen::Vector3d dw_b = (w1 - w0) / dt;\n        const Eigen::Vector3d dv_i = (v1 - v0) / dt;\n\n        const Eigen::Vector3d a_coriolis(0., 0., 0.); // r_p_b is constant\n        const Eigen::Vector3d a_centrifugal = -w_b.cross(w_b.cross(r_p_b));\n        const Eigen::Vector3d a_euler = -dw_b.cross(r_p_b);\n        const Eigen::Vector3d a_imp = dv_i + Eigen::Vector3d(0., 0., g);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='timer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#pragma once\n\n#include <string>\n\n#include <Eigen/Dense>\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/info_parser.hpp>\n\n/**\n * An auxiliary function which loads an Eigen matrix or a scalar from a file.\n * The file uses property tree data structure with INFO format.\n *\n * It has the following format:\t<br>\n * \n * scalarName   value   <br>\n *\n * matrixName\t<br>\n * {\t<br>\n *   scaling 1e+0\t\t\t\t<br>\n *   (0,0) value    ; M(0,0)\t<br>\n *   (1,0) value    ; M(1,0)\t<br>\n *   (0,1) value    ; M(0,1)\t<br>\n *   (1,1) value    ; M(1,1)\t<br>\n * } \t<br>\n *\n * If a value for a specific element is not defined it will set by default to zero.\n *\n * For vectors the second index can be left out.\n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\n// Eigen::Quaterniond q0;\n        // q0.w() = X.at(k)(7);\n        // q0.vec() << X.at(k).segment<3>(8);\n        // q0.normalize();\n        // Eigen::Quaterniond q1;\n        // q1.w() = X.at(k + 1)(7);\n        // q1.vec() << X.at(k + 1).segment<3>(8);\n        // q1.normalize();\n        // const Eigen::Quaterniond q = q0.slerp(0.5, q1);\n\n        const Eigen::Vector3d w0 = X.at(k).segment<3>(11);\n        const Eigen::Vector3d w1 = X.at(k + 1).segment<3>(11);\n        const Eigen::Vector3d w_b = (w1 - w0) / 2;\n\n        const Eigen::Vector3d dw_b = (w1 - w0) / dt;\n        const Eigen::Vector3d dv_i = (v1 - v0) / dt;\n\n        const Eigen::Vector3d a_coriolis(0., 0., 0.); // r_p_b is constant\n        const Eigen::Vector3d a_centrifugal = -w_b.cross(w_b.cross(r_p_b));\n        const Eigen::Vector3d a_euler = -dw_b.cross(r_p_b);\n        const Eigen::Vector3d a_imp = dv_i + Eigen::Vector3d(0., 0., g);\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\n#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\ntimer = tic();\n        std::vector<bool> defects = calculateDefects();\n        print("{:<{}}{:.2f}ms\\n", "Time, defects:", 50, toc(timer));\n        print("Defect pattern:\\n");\n        for (bool defect : defects)\n        {\n            print("{}", defect ? "x" : "-");\n        }\n        print("\\n\\n");\n\n        if (not success)\n        {\n            print("Solver failed to find a solution. Terminating.\\n");\n            std::terminate();\n        }\n\n        readSolution();\n\n        double norm1_nu;\n        socp->getVariableValue("norm1_nu", norm1_nu);\n\n        Eigen::VectorXd delta;\n        socp->getVariableValue("delta", delta);\n        double sum_delta = delta.sum();\n\n        double delta_sigma;\n        socp->getVariableValue("delta_sigma", delta_sigma);\n\n        if (norm1_nu < nu_tol)\n        {\n            weight_trust_region_trajectory *= 2.;\n        }\n\n#pragma once\n\n#include <string>\n\n#include <Eigen/Dense>\n#include <fmt/format.h>\n#include <fmt/ostream.h>\n\n#include <boost/property_tree/ptree.hpp>\n#include <boost/property_tree/info_parser.hpp>\n\n/**\n * An auxiliary function which loads an Eigen matrix or a scalar from a file.\n * The file uses property tree data structure with INFO format.\n *\n * It has the following format:\t<br>\n * \n * scalarName   value   <br>\n *\n * matrixName\t<br>\n * {\t<br>\n *   scaling 1e+0\t\t\t\t<br>\n *   (0,0) value    ; M(0,0)\t<br>\n *   (1,0) value    ; M(1,0)\t<br>\n *   (0,1) value    ; M(0,1)\t<br>\n *   (1,1) value    ; M(1,1)\t<br>\n * } \t<br>\n *\n * If a value for a specific element is not defined it will set by default to zero.\n *\n * For vectors the second index can be left out.\n */\nHuman: template <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a Quaternion object and converts it to Euler angles (roll, pitch, yaw) using the ZYX convention. It first calculates the roll angle (phi) using the formula atan2(R(1, 0), R(0, 0)), where R is the rotation matrix obtained from the Quaternion. It then calculates the pitch angle (theta) using the formula asin(-R(2, 0)). Finally, it calculates the yaw angle (psi) using the formula atan2(R(2, 1), R(2, 2)). The resulting Euler angles are returned as a 3x1 column vector. This function is used in conjunction with the vectorToQuaternion function to convert between Quaternion and Euler angle representations. It is part of the Eigen library, which provides efficient linear algebra operations for matrices and vectors.'}

scpp::models::vectorToQuaternion

{'input': 'template <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='template <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/discretization.cpp'}), Document(page_content='#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='template <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/lib/external/eigenIntegration.hpp'}), Document(page_content='void MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'}), Document(page_content='model->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 1> quaternionToEulerZYX(const Eigen::Quaternion<T> &q)\n{\n    const Eigen::Matrix<T, 3, 3> R = q.toRotationMatrix();\n    const T phi = atan2(R(1, 0), R(0, 0));\n    const T theta = asin(-R(2, 0));\n    const T psi = atan2(R(2, 1), R(2, 2));\n    return Eigen::Matrix<T, 3, 1>(psi, theta, phi);\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 3, 1> &v)\n{\n    return Eigen::Quaternion<T>(std::sqrt(1. - v.squaredNorm()), v.x(), v.y(), v.z());\n}\n\ntemplate <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 3, 3> rotationJacobianXYZ(const Eigen::Matrix<T, 3, 1> &eta)\n{\n    // const T phi = eta.x();\n    const T theta = eta.y();\n    const T psi = eta.z();\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n#include "discretization.hpp"\n#include "discretizationImplementation.hpp"\n\n#include <eigen3/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h>\n\nnamespace scpp::discretization\n{\n\n#ifndef BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n#define BOOST_NUMERIC_ODEINT_EXTERNAL_EIGEN_EIGEN_ALGEBRA_HPP_INCLUDED\n\n#include <Eigen/Dense>\n#include <boost/numeric/odeint/algebra/vector_space_algebra.hpp>\n#include <boost/version.hpp>\n\n// Necessary routines for Eigen matrices to work with vector_space_algebra\n// from odeint\n// (that is, it lets odeint treat the Eigen matrices correctly, knowing\n// how to add, multiply, compute the norm, etc)\n\n#if (EIGEN_VERSION_AT_LEAST(3, 3, 0) && BOOST_VERSION < 107100)\nnamespace Eigen\n{\nnamespace internal\n{\n\ntemplate <typename D>\ninline const typename Eigen::CwiseUnaryOp<\n    typename Eigen::internal::scalar_add_op<\n        typename Eigen::internal::traits<D>::Scalar>,\n    const D>\noperator+(const typename Eigen::MatrixBase<D> &m,\n          const typename Eigen::internal::traits<D>::Scalar &s)\n{\n    return Eigen::CwiseUnaryOp<\n        typename Eigen::internal::scalar_add_op<\n            typename Eigen::internal::traits<D>::Scalar>,\n        const D>(m.derived(), Eigen::internal::scalar_add_op<\n                                  typename Eigen::internal::traits<D>::Scalar>(s));\n}\n\nvoid MPCAlgorithm::solve()\n{\n    assert(initialized);\n\n    print("Solving problem.\\n");\n    const double timer_solve = tic();\n    if (nondimensionalize)\n    {\n        model->nondimensionalize();\n    }\n\n    solver->solve(false);\n\n    print("Solver message:\\n");\n    print("> {}\\n", solver->getResultString());\n\n    if (nondimensionalize)\n    {\n        model->redimensionalize();\n    }\n    print("{:<{}}{:.2f}ms\\n", "Time, solve:", 50, toc(timer_solve));\n\n    readSolution();\n}\n\nvoid MPCAlgorithm::readSolution()\n{\n    cvx::MatrixX v_X, v_U;\n    socp->getVariable("X", v_X);\n    socp->getVariable("U", v_U);\n    Eigen::MatrixXd X = eval(v_X);\n    Eigen::MatrixXd U = eval(v_U);\n\n    for (size_t k = 0; k < K; k++)\n    {\n        this->X[k] = X.col(k);\n    }\n    for (size_t k = 0; k < K-1; k++)\n    {\n        this->U[k] = U.col(k);\n    }\n}\n\nvoid MPCAlgorithm::getSolution(Model::state_vector_v_t &X, Model::input_vector_v_t &U)\n{\n    X = this->X;\n    U = this->U;\n}\n\n} // namespace scpp\n\nmodel->Jacobian(input_view, J_view);\n#else\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM);\n    input << x, u;\n    Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM, Eigen::RowMajor> J;\n    dynamic_vector_map_t J_map(J.data(), J.size());\n\n    J_map << f_.Jacobian(input);\n#endif\n\n    A = J.template block<STATE_DIM, STATE_DIM>(0, 0);\n    B = J.template block<STATE_DIM, INPUT_DIM>(0, STATE_DIM);\n}\n\n} // namespace scpp\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\nHuman: template <typename T>\nEigen::Quaternion<T> vectorToQuaternion(const Eigen::Matrix<T, 4, 1> &v)\n{\n    return Eigen::Quaternion<T>(v(3), v(0), v(1), v(2));\n}\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function quaternionToEulerZYX takes a quaternion as input and returns a vector containing the Euler angles in z-y-x order. It first converts the quaternion to a rotation matrix using the toRotationMatrix() method, then calculates the Euler angles using the atan2() and asin() functions. The resulting vector is returned as output. This function is used in the context of 3D rotations and transformations.'}

scpp::models::Rocket2d::Parameters::loadFromFile

{'input': '    void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\n        param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#include "rocket2d.hpp"\n#include "common.hpp"\n\nnamespace scpp::models\n{\n\n    void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n#include "rocket2d.hpp"\n#include "common.hpp"\n\nnamespace scpp::models\n{\n\n    void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);\n\nparam.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\nHuman:     void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\n        param.loadScalar("m", m);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("constrain_initial_final", constrain_initial_final);\n        param.loadScalar("add_slack_variables", add_slack_variables);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(w_init);\n        deg2rad(w_final);\n        deg2rad(eta_init);\n        deg2rad(eta_final);\n\n        x_init << r_init, v_init, eta_init, w_init;\n        x_final << r_final, v_final, eta_final, w_final;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `Rocket2d::Parameters::loadFromFile(const std::string &path)` is responsible for loading parameters from a file into the `Parameters` class of the `Rocket2d` model. It creates a `ParameterServer` object with the specified path and loads various parameters such as mass, moment of inertia, initial and final positions, velocities, and orientations, as well as final time, constraints, and slack variables. The function also converts angles to radians. This function is called by the `loadParameters()` function in the `Rocket2d` class.'}

scpp::models::Rocket2d::Parameters::nondimensionalize

{'input': '    void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\n        m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\nHuman:     void Rocket2d::Parameters::nondimensionalize()\n    {\n        r_scale = x_init.head(2).norm();\n        m_scale = m;\n\n        m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" in the "Rocket2d" class of the "scpp::models" namespace is responsible for removing mass and length dimensions from all function parameters. It first calculates the scale factor for radius (r_scale) and mass (m_scale) based on the initial position (x_init) and mass (m) respectively. It then scales the mass (m), radius to body (r_T_B), inertia tensor about body (g_I), moment of inertia about body (J_B), initial position (x_init), final position (x_final), minimum and maximum thrust times (T_min and T_max) accordingly. This function is called when the system needs to be nondimensionalized.'}

scpp::models::Rocket2d::Parameters::redimensionalize

{'input': '    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\nHuman:     void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "Rocket2d::Parameters::redimensionalize()" multiplies the mass (m), thrust (r_T_B), moment of inertia (J_B), initial and final positions (x_init and x_final), and time limits (T_min and T_max) by the specified scales (m_scale and r_scale). This function is used to change the dimensions of the parameters from non-dimensional to dimensional or vice versa. It is called by the "redimensionalize()" function in the "SystemModel" base class, which is inherited by the "Rocket2d" class. The "redimensionalize()" function in the base class is required to be implemented by the derived class, which is done here. This function is called by the "redimensionalize()" function in the "Rocket2d" class, which is used to change the dimensions of the parameters before simulation or optimization.'}

scpp::models::Rocket2d::addApplicationConstraints

{'input': '    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        if (p.constrain_initial_final)\n        {\n            // Initial and final state\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_init), v_X.col(0)));\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_final), v_X.rightCols(1)));\n            socp->addConstraint(cvx::equalTo(v_U(0, v_U.cols() - 1), 0.));\n        }\n\n        // State Constraints:\n        // Glideslope\n        socp->addConstraint(cvx::lessThan(v_X.row(0).colwise().norm(),\n                                          cvx::dynpar(p.tan_gamma_gs) * v_X.row(1)));\n        // // Max Tilt Angle\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.theta_max),\n                                     v_X.row(4),\n                                     cvx::dynpar(p.theta_max)));\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.w_B_max),\n                                     v_X.row(5),\n                                     cvx::dynpar(p.w_B_max)));\n\n        // Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='// sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxProblem.cpp'}), Document(page_content='for (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='if (p.constrain_initial_final)\n        {\n            // Initial and final state\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_init), v_X.col(0)));\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_final), v_X.rightCols(1)));\n            socp->addConstraint(cvx::equalTo(v_U(0, v_U.cols() - 1), 0.));\n        }\n\n        // State Constraints:\n        // Glideslope\n        socp->addConstraint(cvx::lessThan(v_X.row(0).colwise().norm(),\n                                          cvx::dynpar(p.tan_gamma_gs) * v_X.row(1)));\n        // // Max Tilt Angle\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.theta_max),\n                                     v_X.row(4),\n                                     cvx::dynpar(p.theta_max)));\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.w_B_max),\n                                     v_X.row(5),\n                                     cvx::dynpar(p.w_B_max)));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n// sum(nu_bound) <= norm1_nu\n            socp->addConstraint(cvx::lessThan(v_nu_bound.sum(), v_norm1_nu));\n\n            // Minimize the virtual control\n            socp->addCostTerm(cvx::dynpar(weight_virtual_control) * v_norm1_nu);\n        }\n\n        for (size_t k = 0; k < td.n_U(); k++)\n        {\n            /**\n             * Build input trust region:\n             *     norm2(u - u0)  <=  trust_region\n             *\n             */\n            cvx::VectorX norm2_args = cvx::dynpar(td.U.at(k)) + -v_U.col(k);\n\n            socp->addConstraint(cvx::lessThan(norm2_args.norm(), cvx::dynpar(trust_region)));\n        }\n\n        return socp;\n    }\n\n} // namespace scpp\n\nfor (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\n\nif (p.constrain_initial_final)\n        {\n            // Initial and final state\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_init), v_X.col(0)));\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_final), v_X.rightCols(1)));\n            socp->addConstraint(cvx::equalTo(v_U(0, v_U.cols() - 1), 0.));\n        }\n\n        // State Constraints:\n        // Glideslope\n        socp->addConstraint(cvx::lessThan(v_X.row(0).colwise().norm(),\n                                          cvx::dynpar(p.tan_gamma_gs) * v_X.row(1)));\n        // // Max Tilt Angle\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.theta_max),\n                                     v_X.row(4),\n                                     cvx::dynpar(p.theta_max)));\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.w_B_max),\n                                     v_X.row(5),\n                                     cvx::dynpar(p.w_B_max)));\nHuman:     void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        if (p.constrain_initial_final)\n        {\n            // Initial and final state\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_init), v_X.col(0)));\n            socp->addConstraint(cvx::equalTo(cvx::dynpar(p.x_final), v_X.rightCols(1)));\n            socp->addConstraint(cvx::equalTo(v_U(0, v_U.cols() - 1), 0.));\n        }\n\n        // State Constraints:\n        // Glideslope\n        socp->addConstraint(cvx::lessThan(v_X.row(0).colwise().norm(),\n                                          cvx::dynpar(p.tan_gamma_gs) * v_X.row(1)));\n        // // Max Tilt Angle\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.theta_max),\n                                     v_X.row(4),\n                                     cvx::dynpar(p.theta_max)));\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.w_B_max),\n                                     v_X.row(5),\n                                     cvx::dynpar(p.w_B_max)));\n\n        // Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a vector of doubles as input and returns its square root. It is a member function of the Math class, which provides various mathematical operations. The square root calculation is performed using the built-in std::sqrt function. The function is named sqrt and has no parameters besides the input vector. It is an inline function, meaning it is expanded in-place during compilation. The function is also const, meaning it does not modify any data members of the Math class.'}

scpp::models::Rocket2d::getInitializedTrajectory

{'input': '    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='if (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nif (t == this->t)\n    {\n        return X.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::state_vector_t x0 = X.at(i);\n    const typename Model::state_vector_t x1 = X.at(i + 1);\n\n    return x0 + interpolate_value * (x1 - x0);\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_X() const\n{\n    return X.size();\n}\n\ntemplate <class Model>\nsize_t TrajectoryData<Model>::n_U() const\n{\n    return U.size();\n}\n\n} // namespace scpp\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\nHuman:     void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    In the context of the Rocket2d model, the function redimensionalizeTrajectory adjusts the dimensions of the trajectory data by scaling the position and velocity components by the radius and mass scale factors, respectively. This is done to maintain consistency with the dimensionality of the model\'s parameters and inputs. The function takes a trajectory data object as input and modifies its X and U components accordingly. This function is called by the getInitializedTrajectory function, which initializes the trajectory data with the specified initial and final states, and by the loadParameters function, which loads the model\'s parameters from a file. The Rocket2d model is part of the SCpp framework for solving optimal control problems using semidefinite programming.'}

scpp::models::Rocket2d::getNewModelParameters

{'input': '    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nvoid RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\nHuman:     void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The Rocket2d class is a subclass of SystemModel, which provides a framework for modeling dynamic systems. \n    The Rocket2d class specifically models a 2D rocket, with parameters such as mass, moment of inertia, and thrust. \n    The system flow map function, systemFlowMap, calculates the derivative of the state vector based on the current state and input vector. \n    The getOperatingPoint function returns the equilibrium point for linearization purposes. \n    The addApplicationConstraints function adds constraints to the optimization problem, such as limits on input and output variables. \n    The nondimensionalize and redimensionalize functions scale and unscale the parameters and variables, respectively, for simulation and analysis purposes. \n    The loadParameters function loads the model parameters from a file, and the getNewModelParameters function extracts the necessary parameters for simulation. \n    The simulate function performs a single step of the simulation, updating the state vector and time. \n    The main simulation loop uses this function to iterate through the simulation until a stopping condition is met. \n    The simulation results are stored in vectors for later analysis.'}

scpp::models::Rocket2d::getOperatingPoint

{'input': '    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n#include "commonFunctions.hpp"\n\nnamespace scpp\n{\n\nModel::input_vector_t interpolatedInput(const Model::input_vector_v_t &U, double t,\n                                        double total_time, bool first_order_hold)\n{\n    const size_t K = U.size();\n    const double time_step = total_time / (K - 1);\n    const size_t i = std::min(size_t(t / time_step), K - 2);\n    const Model::input_vector_t u0 = U.at(i);\n    const Model::input_vector_t u1 = first_order_hold ? U.at(i + 1) : u0;\n\n    const double t_intermediate = std::fmod(t, time_step) / time_step;\n    const Model::input_vector_t u = u0 + (u1 - u0) * t_intermediate;\n\n    return u;\n}\nHuman:     void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The Rocket2d class, which is derived from SystemModel, provides a nonlinear dynamic model for a two-dimensional rocket. It includes functions for system flow mapping, getting the operating point, adding application constraints, nondimensionalizing and redimensionalizing the model, getting and setting the initial and final states, setting state and input weights, and loading and getting new model parameters. The function getOperatingPoint sets the initial state and input to zero.'}

scpp::models::Rocket2d::loadParameters

{'input': '    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/MPC_sim.cpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n\n#include "rocket2dDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 2D rocket model.\n * \n */\n\n#include <experimental/filesystem>\n\n#include "MPCAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n * @brief Simulates a trajectory with the MPC controller.\n * \n */\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nclass ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>\nHuman:     void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function RocketQuat::Parameters::loadFromFile(const std::string &path) is responsible for loading parameters from a specified file path. It creates a ParameterServer object to read the file and extracts various parameters such as initial and final states, thrust, and moments of inertia. These parameters are stored in local variables within the function. The function does not return any value but rather sets the parameters for further use in the RocketQuat class. This function is called by the RocketQuat constructor to initialize its parameters.'}

scpp::models::Rocket2d::nondimensionalize

{'input': '    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\nHuman:     void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" in the "Rocket2d" class of the "scpp::models" namespace is responsible for removing mass and length dimensions from all function parameters. It is a virtual function that needs to be implemented by the derived class. This function is called before simulation or optimization to ensure consistency in units. The function takes no arguments and does not return any value. It modifies the "Parameters" structure, which contains the model parameters, by dividing certain variables by specific scales. The function is part of a larger simulation and optimization framework called "scpp" (Simulation and Control Platform) developed by the authors.'}

scpp::models::Rocket2d::nondimensionalizeTrajectory

{'input': '    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\nHuman:     void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)" is responsible for removing mass and length dimensions from all trajectory data points in the given "trajectory_data_t" object. This is achieved by dividing the position and velocity components by the radius scale factor "r_scale" and the thrust component by the mass and radius scale factors "m_scale" and "r_scale", respectively. The function does not modify the time component of the trajectory data. This function is called in the "nondimensionalize" function of the "Rocket2d" class, which is used to remove mass and length dimensions from all function parameters.'}

scpp::models::Rocket2d::redimensionalize

{'input': '    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n/**\n     * @brief Function to remove mass and length dimensions from state and input trajectory.\n     * \n     */\n    virtual void nondimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("nondimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to state and input trajectory.\n     * \n     */\n    virtual void redimensionalizeTrajectory(trajectory_data_t &)\n    {\n        throw std::runtime_error("redimensionalizeTrajectory: This function has to be implemented by the derived class.");\n    };\n\n    static const std::string getModelName()\n    {\n        return DERIVED::modelName;\n    };\n\n    void setParameterFolder(const std::string &path)\n    {\n        param_folder_path = path;\n    };\n\n    const std::string getParameterFolder() const\n    {\n        return param_folder_path + getModelName();\n    };\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\nHuman:     void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" in the "Rocket2d" class is used to remove mass and length dimensions from all function parameters. It is a virtual function that needs to be implemented by the derived class. This function is called before running simulations to ensure consistency in units. The function takes no arguments and throws a runtime error if not implemented by the derived class. The function scales the mass, radius, and time variables by their respective scales, and also scales the initial and final states and time horizon. The "redimensionalize" function is used to add mass and length dimensions back to the parameters, and is also a virtual function that needs to be implemented by the derived class. Both functions are part of the "SystemModel" template class, which provides a common interface for modeling dynamic systems. The "getOperatingPoint" function is used to obtain the operating point of the system, usually an equilibrium point for linearization, and is also a virtual function that needs to be implemented by the derived class. The "nondimensionalizeTrajectory" and "redimensionalizeTrajectory" functions are used to remove and add mass and length dimensions to the state and input trajectory, respectively, and are also virtual functions that need to be implemented by the derived class. The "getModelName" function returns the name of the model, which is "Rocket2D" in this case, and is a static const member function of the "Rocket2d" class. The "setParameterFolder" and "getParameterFolder" functions are used to set and get the path to the parameter folder, respectively, and are member functions of the "Rocket2d" class. The "addApplicationConstraints" function is used to add application constraints to the optimization problem, and is a virtual function that needs to be implemented by the derived class. The "getNewModelParameters" function is used to get the new model parameters, and is a virtual function that needs to be implemented by the derived class. The "getInitializedTrajectory" function is used to get the initialized trajectory, and is a virtual function that needs to be implemented by the derived class. The "systemFlowMap" function is used to compute the system flow map, and is a virtual function that needs to be implemented by the derived class. The "RocketQuat" and "Model" aliases are used to simplify the code, and the "loadParameters" function is used to'}

scpp::models::Rocket2d::redimensionalizeTrajectory

{'input': '    void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\nHuman:     void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    In the Rocket2d class, the redimensionalizeTrajectory() function is used to scale the state and input vectors of a trajectory based on the rocket\'s mass and radius scales. The state vector is scaled by the radius scale, while the input vector\'s thrust component is scaled by both the mass and radius scales. This function is called after loading the parameters from a file and before simulating the rocket\'s trajectory. It is also used when initializing a trajectory with randomized parameters. This function is part of the larger RocketQuat class, which extends the Rocket2d class to include quaternion-based orientation dynamics.'}

scpp::models::Rocket2d::systemFlowMap

{'input': '    void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);\n\n        f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "rocket2d.hpp"\n#include "common.hpp"\n\nnamespace scpp::models\n{\n\n    void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class SystemDynamics\n{\npublic:\n    using state_vector_t = Eigen::Matrix<double, STATE_DIM, 1>;\n    using state_matrix_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM>;\n    using input_vector_t = Eigen::Matrix<double, INPUT_DIM, 1>;\n    using input_matrix_t = Eigen::Matrix<double, INPUT_DIM, INPUT_DIM>;\n    using control_matrix_t = Eigen::Matrix<double, STATE_DIM, INPUT_DIM>;\n    using feedback_matrix_t = Eigen::Matrix<double, INPUT_DIM, STATE_DIM>;\n    using param_vector_t = Eigen::Matrix<double, PARAM_DIM, 1>;\n    using dynamic_vector_t = Eigen::Matrix<double, Eigen::Dynamic, 1>;\n    using dynamic_matrix_t = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;\n    using dynamic_vector_map_t = Eigen::Map<dynamic_vector_t>;\n\n    using state_vector_v_t = std::vector<state_vector_t>;\n    using input_vector_v_t = std::vector<input_vector_t>;\n    using state_matrix_v_t = std::vector<state_matrix_t>;\n    using control_matrix_v_t = std::vector<control_matrix_t>;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='m /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='Eigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/common.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "rocket2d.hpp"\n#include "common.hpp"\n\nnamespace scpp::models\n{\n\n    void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);\n\nclass Rocket2d : public SystemModel<Rocket2d, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    Rocket2d() = default;\n\n    inline static const std::string modelName = "Rocket2D";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getOperatingPoint(state_vector_t &x, input_vector_t &u) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\nclass SystemDynamics\n{\npublic:\n    using state_vector_t = Eigen::Matrix<double, STATE_DIM, 1>;\n    using state_matrix_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM>;\n    using input_vector_t = Eigen::Matrix<double, INPUT_DIM, 1>;\n    using input_matrix_t = Eigen::Matrix<double, INPUT_DIM, INPUT_DIM>;\n    using control_matrix_t = Eigen::Matrix<double, STATE_DIM, INPUT_DIM>;\n    using feedback_matrix_t = Eigen::Matrix<double, INPUT_DIM, STATE_DIM>;\n    using param_vector_t = Eigen::Matrix<double, PARAM_DIM, 1>;\n    using dynamic_vector_t = Eigen::Matrix<double, Eigen::Dynamic, 1>;\n    using dynamic_matrix_t = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;\n    using dynamic_vector_map_t = Eigen::Map<dynamic_vector_t>;\n\n    using state_vector_v_t = std::vector<state_vector_t>;\n    using input_vector_v_t = std::vector<input_vector_t>;\n    using state_matrix_v_t = std::vector<state_matrix_t>;\n    using control_matrix_v_t = std::vector<control_matrix_t>;\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nm /= m_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) /= r_scale;\n        x_init.segment<2>(2) /= r_scale;\n\n        x_final.segment<2>(0) /= r_scale;\n        x_final.segment<2>(2) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n    }\n\n    void Rocket2d::Parameters::redimensionalize()\n    {\n        m *= m_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init.segment<2>(0) *= r_scale;\n        x_init.segment<2>(2) *= r_scale;\n\n        x_final.segment<2>(0) *= r_scale;\n        x_final.segment<2>(2) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\n/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);\n\nEigen::Matrix<T, 3, 3> M;\n    M.row(0) << cos(psi), -sin(psi), T(0.);\n    M.row(1) << cos(theta) * sin(psi), cos(theta) * cos(psi), T(0.);\n    M.row(2) << -sin(theta) * cos(psi), sin(theta) * sin(psi), cos(theta);\n\n    return M / cos(theta);\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 2, 2> rotationJacobianXY(const Eigen::Matrix<T, 2, 1> &eta)\n{\n    const T theta = eta.y();\n\n    Eigen::Matrix<T, 2, 2> M;\n    M.row(0) << cos(theta), sin(theta);\n    M.row(1) << -sin(theta), cos(theta);\n\n    return M;\n}\n\ntemplate <typename T>\nEigen::Matrix<T, 4, 4> omegaMatrix(const Eigen::Matrix<T, 3, 1> &w)\n{\n    Eigen::Matrix<T, 4, 4> omega;\n    omega << T(0.), -w(0), -w(1), -w(2),\n        w(0), T(0.), w(2), -w(1),\n        w(1), -w(2), T(0.), w(0),\n        w(2), w(1), -w(0), T(0.);\n\n    return omega;\n}\nHuman:     void Rocket2d::systemFlowMap(const state_vector_ad_t &x,\n                                 const input_vector_ad_t &u,\n                                 const param_vector_ad_t &par,\n                                 state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto m = par(0);\n        auto J_B = par(1);\n        auto g_I = par.segment<2>(2);\n        auto r_T_B = par.segment<2>(4);\n        // = 6 parameters\n\n        // state variables\n        // x, y, vx, vy, eta, omega\n        Eigen::Matrix<T, 2, 1> v = x.segment<2>(2);\n        T eta = x(4);\n        T w = x(5);\n\n        // input variables\n        T angle = u(0);\n        T magnitude = u(1);\n        Eigen::Matrix<T, 2, 1> T_B =\n            Eigen::Rotation2D<T>(angle) * Eigen::Matrix<T, 2, 1>(0., magnitude);\n\n        Eigen::Rotation2D<T> R_I_B(eta);\n\n        f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "Rocket2d::systemFlowMap" is a member function of the "Rocket2d" class in the "scpp::models" namespace. It takes as input a state vector, an input vector, a parameter vector, and outputs a state derivative vector. The function calculates the derivative of the state variables based on the input variables and parameters, which are used to simulate the dynamics of a rocket in two dimensions. The function uses several matrices and vectors, such as "M", "R_I_B", and "omegaMatrix", to perform rotations and calculations related to angular velocity. The function also includes a "getOperatingPoint" function, which sets the initial state and input values for simulation, and an "addApplicationConstraints" function, which adds constraints to optimization problems. The function is part of a larger system dynamics framework called "SystemDynamics" that provides functions for computing the state derivative, Jacobians, and other related operations.'}

scpp::models::RocketQuat::Parameters::loadFromFile

{'input': '    void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n        param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='struct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_sim.cpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nparam.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n\nstruct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    const double time_step = 0.05;\n    const size_t max_steps = 100;\n\n    trajectory_data_t td;\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n\n    Model::state_vector_t &x = model->p.x_init;\n\n    double timer_run = tic();\n    size_t sim_step = 0;\n    while (sim_step < max_steps)\n    {\n        print("\\n{:*^{}}\\n\\n", format("<SIMULATION STEP {}>", sim_step), 60);\n\n        const bool warm_start = sim_step > 0;\n        solver.solve(warm_start);\n        solver.getSolution(td);\n\n        const Model::input_vector_t u0 = td.U.at(0);\n        const bool first_order_hold = td.interpolatedInput();\n        const Model::input_vector_t u1 = scpp::interpolatedInput(td.U, time_step, td.t, first_order_hold);\n\n        scpp::simulate(model, time_step, u0, u1, x);\n\n        X_sim.push_back(x);\n        U_sim.push_back(u0);\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\nvoid SystemDynamics<STATE_DIM, INPUT_DIM, PARAM_DIM>::computeJacobians(const state_vector_t &x,\n                                                                       const input_vector_t &u,\n                                                                       state_matrix_t &A,\n                                                                       control_matrix_t &B)\n{\n    assert(initialized and parameters_set);\n\n#if CODEGEN\n    dynamic_vector_t input(STATE_DIM + INPUT_DIM + PARAM_DIM);\n    input << x, u, current_parameters;\n\n    using full_jacobian_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM + INPUT_DIM + PARAM_DIM, Eigen::RowMajor>;\n    full_jacobian_t J;\n\n    CppAD::cg::ArrayView<const double> input_view(input.data(), input.size());\n    CppAD::cg::ArrayView<double> J_view(J.data(), J.size());\nHuman:     void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n        param.loadMatrix("g_I", g_I);\n        param.loadMatrix("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n        param.loadScalar("m_init", m_init);\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadMatrix("rpy_init", rpy_init);\n        param.loadMatrix("w_init", w_init);\n        param.loadMatrix("w_final", w_final);\n        param.loadScalar("m_dry", m_dry);\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadMatrix("rpy_final", rpy_final);\n        param.loadScalar("T_min", T_min);\n        param.loadScalar("T_max", T_max);\n        param.loadScalar("t_max", t_max);\n        param.loadScalar("I_sp", I_sp);\n        param.loadScalar("gimbal_max", gimbal_max);\n        param.loadScalar("theta_max", theta_max);\n        param.loadScalar("gamma_gs", gamma_gs);\n        param.loadScalar("w_B_max", w_B_max);\n        param.loadScalar("random_initial_state", random_initial_state);\n        param.loadScalar("final_time", final_time);\n        param.loadScalar("exact_minimum_thrust", exact_minimum_thrust);\n        param.loadScalar("enable_roll_control", enable_roll_control);\n\n        deg2rad(gimbal_max);\n        deg2rad(theta_max);\n        deg2rad(gamma_gs);\n        deg2rad(w_B_max);\n        deg2rad(rpy_init);\n        deg2rad(rpy_final);\n        deg2rad(w_init);\n        deg2rad(w_final);\n\n        alpha_m = 1. / (I_sp * fabs(g_I(2)));\n\n        const auto q_init = eulerToQuaternionXYZ(rpy_init);\n        const auto q_final = eulerToQuaternionXYZ(rpy_final);\n        x_init << m_init, r_init, v_init, q_init.w(), q_init.vec(), w_init;\n        if (random_initial_state)\n        {\n            randomizeInitialState();\n        }\n        x_final << m_dry, r_final, v_final, q_final.w(), q_final.vec(), w_final;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function takes a string path as input and loads parameters from a file with the given path. The parameters include initial and final states, thrust limits, and other physical constants. The function also sets flags for randomizing initial states and enabling roll control. The parameters are stored in the struct Parameters, which is used throughout the codebase for simulation and optimization purposes.'}

scpp::models::RocketQuat::Parameters::nondimensionalize

{'input': '    void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n// Control Constraints:\n        // Gimbal Range\n        socp->addConstraint(cvx::box(-cvx::dynpar(p.gimbal_max),\n                                     v_U.row(0),\n                                     cvx::dynpar(p.gimbal_max)));\n        // Thrust Range\n        socp->addConstraint(cvx::box(cvx::dynpar(p.T_min),\n                                     v_U.row(1),\n                                     cvx::dynpar(p.T_max)));\n    }\n\n    void Rocket2d::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void Rocket2d::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void Rocket2d::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) /= p.m_scale * p.r_scale;\n        }\n    }\n\n#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nvoid MPCAlgorithm::initialize()\n{\n    print("[MPC] Starting controller for model \'{}\'.\\n", Model::getModelName());\n\n    assert(state_weights_set and input_weights_set);\n\n    X.resize(K);\n    U.resize(K - 1);\n\n    model->updateModelParameters();\n\n    print("[MPC] Discretizing.\\n");\n    const double timer_discretize = tic();\n    Model::state_vector_t x_eq;\n    Model::input_vector_t u_eq;\n    model->getOperatingPoint(x_eq, u_eq);\n    const double dt = time_horizon / (K - 1);\n    scpp::discretization::exactLinearDiscretization(model, dt, x_eq, u_eq, A, B, z);\n    print("{:<{}}{:.2f}ms\\n", "[MPC] Time, discretization:", 50, toc(timer_discretize));\n\n    socp = buildMPCProblem(X, U,\n                           x_init, x_final,\n                           state_weights_intermediate, state_weights_terminal, input_weights,\n                           A, B, z,\n                           constant_dynamics, intermediate_cost_active);\n    model->addApplicationConstraints(socp, X, U);\nHuman:     void RocketQuat::Parameters::nondimensionalize()\n    {\n        m_scale = x_init(0);\n        r_scale = x_init.segment(1, 3).norm();\n\n        alpha_m *= r_scale;\n        r_T_B /= r_scale;\n        g_I /= r_scale;\n        J_B /= m_scale * r_scale * r_scale;\n\n        x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function RocketQuat::Parameters::nondimensionalize is responsible for removing mass and length dimensions from all parameters of the RocketQuat model. It first saves the initial mass and radius as scale factors, then scales the mass, radius, and thrust vector by the inverse of these scale factors. It also scales the inertia matrix and the gimbal range constraints by the inverse of the square of the radius scale factor. This function is called by the RocketQuat model\'s loadFromFile function, which loads parameters from a file. The function is part of the scpp::models namespace, which provides models for simulation and control purposes.'}

scpp::models::RocketQuat::Parameters::randomizeInitialState

{'input': '    void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='struct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nstruct Parameters\n    {\n        bool exact_minimum_thrust;\n        bool enable_roll_control;\n\n        Eigen::Vector3d g_I;\n        Eigen::Vector3d J_B;\n        Eigen::Vector3d r_T_B;\n        double alpha_m;\n        double T_min;\n        double T_max;\n        double t_max;\n\n        double gimbal_max;\n        double theta_max;\n        double gamma_gs;\n        double w_B_max;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        double m_scale, r_scale;\n\n        void randomizeInitialState();\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n\n        void nondimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n\n        void redimensionalizeTrajectory(state_vector_v_t &X, input_vector_v_t &U) const;\n    } p;\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\nHuman:     void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    The function `void RocketQuat::Parameters::randomizeInitialState()` generates random initial states for the mass, position, velocity, and orientation of the rocket. It uses a uniform distribution between -1 and 1 to modify the values of the initial state vector `x_init`. The function does not take any arguments and does not return any value. It is a member function of the `Parameters` struct, which is part of the `RocketQuat` class. This function can be called before running a simulation to generate a new set of initial conditions.'}

scpp::models::RocketQuat::Parameters::redimensionalize

{'input': '    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\nHuman:     void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function RocketQuat::Parameters::redimensionalize() scales the parameters of the RocketQuat model by the specified scales for mass, length, and time. It divides the alpha_m, r_T_B, and g_I by the r_scale, multiplies the x_init, x_final, and T_min by the m_scale, multiplies the x_init and x_final by the r_scale, and multiplies the T_max and t_max by the m_scale and r_scale and r_scale. This function is called by the loadParameters() and getOperatingPoint() functions, and is used to convert between dimensional and non-dimensional parameters.'}

scpp::models::RocketQuat::addApplicationConstraints

{'input': '    void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n        // Glide Slope\n        socp->addConstraint(cvx::lessThan(v_X.block(1, 0, 2, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gs_const) * v_X.block(3, 0, 1, v_X.cols())));\n\n        // Max Tilt Angle\n        socp->addConstraint(cvx::lessThan(v_X.block(8, 0, 2, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p_dyn.tilt_const)));\n\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::lessThan(v_X.block(11, 0, 3, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p.w_B_max)));\n\n        // Control Constraints:\n        // Final Input\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(0), 0.));\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(1), 0.));\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(3), 0.));\n\n        if (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));\n\n        if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='cvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='for (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'}), Document(page_content='if (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='socp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/MPCProblem.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\ncvx::MatrixX v_X = socp->addVariable("X", Model::state_dim, X.size()); // states\n        cvx::MatrixX v_U = socp->addVariable("U", Model::input_dim, U.size()); // inputs\n        cvx::Scalar v_error_cost = socp->addVariable("error_cost");            // error minimization term\n        cvx::Scalar v_input_cost = socp->addVariable("input_cost");            // input minimization term\n\n        // Initial state\n        for (size_t i = 0; i < Model::state_dim; i++)\n        {\n            socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(x_init)));\n        }\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\nfor (size_t k = 0; k < X.size() - 1; k++)\n        {\n            /**\n             * Build linearized model equality constraint\n             *    x(k+1) == A x(k) + B u(k) + z\n             * \n             */\n            cvx::VectorX lhs;\n            if (constant_dynamics)\n            {\n                lhs = cvx::par(A) * v_X.col(k) +\n                      cvx::par(B) * v_U.col(k) +\n                      cvx::par(z);\n            }\n            else\n            {\n                lhs = cvx::dynpar(A) * v_X.col(k) +\n                      cvx::dynpar(B) * v_U.col(k) +\n                      cvx::dynpar(z);\n            }\n\n            socp->addConstraint(cvx::equalTo(lhs, v_X.col(k + 1)));\n        }\n\nif (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));\n\nsocp = buildSCProblem(weight_time, weight_trust_region_time,\n                              weight_trust_region_trajectory, weight_virtual_control,\n                              td, dd);\n        model->addApplicationConstraints(socp, td.X, td.U);\n        solver = std::make_unique<cvx::ecos::ECOSSolver>(*socp);\n    }\n\n    bool SCAlgorithm::iterate()\n    {\n        // discretize\n        const double timer_iteration = tic();\n        double timer = tic();\n        discretization::multipleShooting(model, td, dd);\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        // solve the problem\n        print("\\n");\n        print("Solving problem.\\n");\n        timer = tic();\n        const bool success = solver->solve(false);\n        print("Solver message:\\n");\n        print("> {}\\n", solver->getResultString());\n        print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n        print("\\n");\n\n#include "MPCProblem.hpp"\n\nnamespace scpp\n{\n\n    std::shared_ptr<cvx::OptimizationProblem> buildMPCProblem(\n        Model::state_vector_v_t &X,\n        Model::input_vector_v_t &U,\n        Model::state_vector_t &x_init,\n        Model::state_vector_t &x_final,\n        Model::state_vector_t &state_weights_intermediate,\n        Model::state_vector_t &state_weights_terminal,\n        Model::input_vector_t &input_weights,\n        Model::state_matrix_t &A,\n        Model::control_matrix_t &B,\n        Model::state_vector_t &z,\n        bool constant_dynamics,\n        bool intermediate_cost_active)\n    {\n        auto socp = std::make_shared<cvx::OptimizationProblem>();\nHuman:     void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\n\n        // Glide Slope\n        socp->addConstraint(cvx::lessThan(v_X.block(1, 0, 2, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gs_const) * v_X.block(3, 0, 1, v_X.cols())));\n\n        // Max Tilt Angle\n        socp->addConstraint(cvx::lessThan(v_X.block(8, 0, 2, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p_dyn.tilt_const)));\n\n        // Max Rotation Velocity\n        socp->addConstraint(cvx::lessThan(v_X.block(11, 0, 3, v_X.cols()).colwise().norm(),\n                                          cvx::dynpar(p.w_B_max)));\n\n        // Control Constraints:\n        // Final Input\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(0), 0.));\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(1), 0.));\n        socp->addConstraint(cvx::equalTo(v_U.col(v_U.cols() - 1)(3), 0.));\n\n        if (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));\n\n        if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example:\n    This function takes a shared pointer to an optimization problem, a vector of states, and a vector of inputs as arguments, and adds constraints related to the rocket\'s dynamics and control limits to the optimization problem. It uses the p_dyn and p structures to store dynamic parameters and control limits, respectively. The function also checks whether exact minimum thrust is enabled and adds the corresponding constraint accordingly. If roll control is disabled, additional constraints are added to fix the roll angle and input. The function returns void.\n\n    Hint: \n    - Use active voice.\n    - Use present tense.\n    - Use bullet points if necessary.\n    - Use technical terms and acronyms without explanation.\n    - Avoid redundancy.\n    - Avoid ambiguity.\n    - Avoid contractions.\n    - Avoid jargon.\n    - Avoid slang.\n    - Avoid humor.\n    - Avoid sarcasm.\n    - Avoid personal opinions.\n    - Avoid personal pronouns.\n    - Avoid passive voice.\n    - Avoid repetition.\n    - Avoid unnecessary details.\n    - Avoid vague language.\n    - Avoid verbosity.\n    - Avoid wordiness.\n    - Avoid writing in the first person.\n    - Avoid writing in the second person.\n    - Avoid writing in the third person.\n    - Avoid using "and" to join two ideas.\n    - Avoid using "but" to join two ideas.\n    - Avoid using "or" to join two ideas.\n    - Avoid using "so" to join two ideas.\n    - Avoid using "because" to join two ideas.\n    - Avoid using "therefore" to join two ideas.\n    - Avoid using "in order to" to join two ideas.\n    - Avoid using "as a result" to join two ideas.\n    - Avoid using "in addition" to join two ideas.\n    - Avoid using "moreover" to join two ideas.\n    - Avoid using "furthermore" to join two ideas.\n    - Avoid using "meanwhile" to join two ideas.\n    - Avoid using "nevertheless" to join two ideas.\n    - Avoid using "thereupon" to join two ideas.\n    - Avoid using "subsequently" to join two ideas.\n    - Avoid using "accordingly" to join'}

scpp::models::RocketQuat::getInitializedTrajectory

{'input': '    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\n            // do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='void multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/discretizationImplementation.hpp'}), Document(page_content='double expMovingAverage(double previousAverage, double period, double newValue)\n{\n    const double factor = 2. / (period + 1.);\n    const double result = (newValue - previousAverage) * factor + previousAverage;\n    return result;\n}\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset,\n                                                          const double g)\n{\n    Model::state_vector_v_t X = td.X;\n    X.push_back(X.back());\n\n    // calculate accelerations\n    std::vector<Eigen::Vector3d> acc_passenger_b;\n    const double dt = td.t / (X.size() - 1);\n\n    for (size_t k = 0; k < X.size() - 1; k++)\n    {\n        const Eigen::Vector3d r_p_b = offset;\n        const Eigen::Vector3d v0 = X.at(k).segment<3>(4);\n        const Eigen::Vector3d v1 = X.at(k + 1).segment<3>(4);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/commonFunctions.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\n#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nvoid multipleShootingImplementation(\n    Model::ptr_t model,\n    trajectory_data_t &td,\n    discretization_data_t &dd)\n{\n    const size_t K = td.n_X();\n\n    using ODEFun = ODE<INTERPOLATE_INPUT, VARIABLE_TIME>;\n    using ode_matrix_t = typename ODEFun::ode_matrix_t;\n\n    double dt = 1. / double(K - 1);\n\n    if constexpr (not VARIABLE_TIME)\n    {\n        dt *= td.t;\n    }\n\n    using namespace boost::numeric::odeint;\n    runge_kutta_fehlberg78<ode_matrix_t, double, ode_matrix_t, double, vector_space_algebra> stepper;\n\n    for (size_t k = 0; k < K - 1; k++)\n    {\n        ode_matrix_t V;\n        V.col(0) = td.X.at(k);\n        V.template block<Model::state_dim, Model::state_dim>(0, 1).setIdentity();\n        V.template rightCols<ode_matrix_t::ColsAtCompileTime - 1 - Model::state_dim>().setZero();\n\n        const Model::input_vector_t u0 = td.U[k];\n        const Model::input_vector_t u1 = INTERPOLATE_INPUT ? td.U[k + 1] : u0;\n        ODEFun odeMultipleShooting(u0, u1, td.t, dt, model);\n\ndouble expMovingAverage(double previousAverage, double period, double newValue)\n{\n    const double factor = 2. / (period + 1.);\n    const double result = (newValue - previousAverage) * factor + previousAverage;\n    return result;\n}\n\nstd::vector<Eigen::Vector3d> getAccelerationRotatingFrame(const trajectory_data_t &td,\n                                                          const Eigen::Vector3d offset,\n                                                          const double g)\n{\n    Model::state_vector_v_t X = td.X;\n    X.push_back(X.back());\n\n    // calculate accelerations\n    std::vector<Eigen::Vector3d> acc_passenger_b;\n    const double dt = td.t / (X.size() - 1);\n\n    for (size_t k = 0; k < X.size() - 1; k++)\n    {\n        const Eigen::Vector3d r_p_b = offset;\n        const Eigen::Vector3d v0 = X.at(k).segment<3>(4);\n        const Eigen::Vector3d v1 = X.at(k + 1).segment<3>(4);\nHuman:     void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\n            // do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Example: \n    This function calculates the determinant of a given matrix using LU decomposition. It takes a const reference to the matrix as input and returns the determinant as a double. The function first checks if the matrix is square, then performs LU decomposition using partial pivoting. The determinant is then calculated as the product of the diagonal elements of the upper triangular matrix. The function does not modify the input matrix.\n\n    Summary: The provided C++ function calculates the determinant of a given matrix using LU decomposition with partial pivoting. It takes a const reference to the matrix as input and returns the determinant as a double without modifying the input matrix. The function first checks if the matrix is square before performing LU decomposition. The determinant is calculated as the product of the diagonal elements of the upper triangular matrix obtained from LU decomposition.'}

scpp::models::RocketQuat::getNewModelParameters

{'input': '    void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'}), Document(page_content='int main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/SC_tracking.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nvoid RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\n\nint main()\n{\n    auto model = std::make_shared<Model>();\n    model->loadParameters();\n\n    scpp::SCAlgorithm solver(model);\n\n    solver.initialize();\n\n    trajectory_data_t td;\n\n    solver.solve();\n    solver.getSolution(td);\n\n    // calculate LQR gains\n    fmt::print("\\n");\n    const double gains_timer = tic();\n    scpp::LQRTracker tracker(model, td);\n    fmt::print("{:<{}}{:.2f}ms\\n", "Time, LQR gains:", 50, 1 * toc(gains_timer));\n\n    const double timestep = 0.01;\n\n    // start simulation\n    const double run_timer = tic();\n\n    Model::state_vector_v_t X_sim;\n    Model::input_vector_v_t U_sim;\n    std::vector<double> t_sim;\n    const double t_max = td.t;\n    const double write_steps = 30;\n\n    Model::state_vector_t x = model->p.x_init;\n\n    const size_t initial_error = (x - model->p.x_final).norm();\n\n    double t = 0.;\n    size_t sim_step = 0;\n\n    while (t < t_max)\n    {\n        // get the calculated input\n        Model::input_vector_t u;\n        tracker.getInput(t, x, u);\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\nHuman:     void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Summary: The RocketQuat::getNewModelParameters() function is a member function of the RocketQuat class, which is a part of the scpp::models namespace. It takes a parameter vector as an input and updates it with the necessary parameters required for the RocketQuat model. The updated parameter vector is then passed to the system flow map function for further calculations. The function also calls the updateProblemParameters() function, which is not explicitly described in the provided context. However, it can be inferred that this function updates the problem parameters based on the new model parameters. The RocketQuat model is used to simulate the motion of a rocket with a quaternion representation of its attitude. The parameters alpha_m, g_I, J_B, and r_T_B are used to define the mass, inertia, and position of the rocket. The function\'s dependency on the Parameters structure is also noted, which contains additional parameters such as scaling factors, time limits, and constraints.'}

scpp::models::RocketQuat::loadParameters

{'input': '    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n#include "common.hpp"\n\n#include "rocketQuatDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 3D rocket landing model.\n * \n */', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='class ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'}), Document(page_content='class MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/MPCAlgorithm.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\n#pragma once\n\n#include <string>\n#include <random>\n\n#include "systemModel.hpp"\n#include "parameterServer.hpp"\n#include "common.hpp"\n\n#include "rocketQuatDefinitions.hpp"\n\nnamespace scpp::models\n{\n\n/**\n * @brief A 3D rocket landing model.\n * \n */\n\n#include "SCAlgorithm.hpp"\n#include "timing.hpp"\n#include "simulation.hpp"\n#include "discretization.hpp"\n\nusing fmt::format;\nusing fmt::print;\nusing std::string;\nusing std::vector;\n\nnamespace scpp\n{\n\n    SCAlgorithm::SCAlgorithm(Model::ptr_t model)\n    {\n        this->model = model;\n        loadParameters();\n\n        all_td.reserve(max_iterations);\n    }\n\n    void SCAlgorithm::loadParameters()\n    {\n        ParameterServer param(model->getParameterFolder() + "/SC.info");\n\n        param.loadScalar("K", K);\n\n        param.loadScalar("free_final_time", free_final_time);\n\n        param.loadScalar("nondimensionalize", nondimensionalize);\n\n        param.loadScalar("delta_tol", delta_tol);\n        param.loadScalar("max_iterations", max_iterations);\n        param.loadScalar("nu_tol", nu_tol);\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n#include <experimental/filesystem>\n\n#include "LQRAlgorithm.hpp"\n#include "simulation.hpp"\n#include "timing.hpp"\n#include "commonFunctions.hpp"\n\nnamespace fs = std::experimental::filesystem;\n\nfs::path getOutputPath() { return fs::path("..") / "output" / Model::getModelName(); }\n\n/**\n     * @brief Function to add constraints of a model. Has to be implemented by the derived class.\n     * \n     * @param socp  The SOCP.\n     * @param X     Last state trajectory.\n     * @param U     Last input trajectory.\n     */\n    virtual void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem>,\n                                           state_vector_v_t &,\n                                           input_vector_v_t &){};\n\n    /**\n     * @brief Gets the new parameters in the system flow map.\n     * \n     */\n    virtual void getNewModelParameters(param_vector_t &){};\n\n    /**\n     * @brief Updates the parameters in the system flow map.\n     * \n     */\n    void updateModelParameters()\n    {\n        param_vector_t model_params;\n        getNewModelParameters(model_params);\n        BASE::updateModelParameters(model_params);\n    };\n\nclass ParameterServer\n{\npublic:\n    explicit ParameterServer(const std::string &filename)\n    {\n        try\n        {\n            boost::property_tree::read_info(filename, pt);\n        }\n        catch (const boost::property_tree::info_parser_error &e)\n        {\n            fmt::print("Could not open file for reading: {}\\n", filename);\n            fmt::print("{}\\n", e.what());\n        }\n    }\n\n    template <typename T>\n    void loadScalar(\n        const std::string &scalarName,\n        T &scalar);\n\n    template <typename T>\n    void loadMatrix(\n        const std::string &matrixName,\n        Eigen::MatrixBase<T> &matrix);\n\nprivate:\n    boost::property_tree::ptree pt;\n};\n\ntemplate <typename T>\n\nclass MPCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new MPC solver.\n     *\n     * @param model     The system model.\n     */\n    explicit MPCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     *\n     */\n    void initialize();\n\n    /**\n     * @brief  Sets a new initial state.\n     *\n     */\n    void setInitialState(const Model::state_vector_t &x);\n\n    /**\n     * @brief  Sets a new desired state to track.\n     *\n     */\n    void setFinalState(const Model::state_vector_t &x);\n\n    /**\n     * @brief Set the state weights\n     * \n     * @param intermediate \n     * @param terminal \n     */\n    void setStateWeights(const Model::state_vector_t &intermediate, const Model::state_vector_t &terminal);\n\n    /**\n     * @brief Set the input weights\n     * \n     * @param intermediate \n     */\n    void setInputWeights(const Model::input_vector_t &intermediate);\nHuman:     void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function RocketQuat::loadParameters() is responsible for loading the parameters of the RocketQuat model from a file named "model.info" located in the parameter folder. The function uses the ParameterServer class to read the parameters from the file and stores them in the p member variable of the RocketQuat class. This function is called by the constructor of the RocketQuat class to initialize its parameters. The ParameterServer class is a wrapper around the Boost Property Tree library, which allows for easy parsing and manipulation of configuration files. The RocketQuat model is a 3D rocket landing model that uses a Quaternion representation for the orientation. It is part of the SC algorithm, which is a model predictive control algorithm for spacecraft landing. The RocketQuat model is used in conjunction with the MPCAlgorithm class, which is responsible for generating optimal control inputs based on the RocketQuat model and other constraints. The MPCAlgorithm class also uses the ParameterServer class to load its own parameters from a separate file.'}

scpp::models::RocketQuat::nondimensionalize

{'input': '    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='void ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/utils/include/parameterServer.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\nvoid ParameterServer::loadMatrix(\n    const std::string &matrixName,\n    Eigen::MatrixBase<T> &matrix)\n{\n    using scalar_t = typename Eigen::MatrixBase<T>::Scalar;\n\n    const scalar_t scaling = pt.get<scalar_t>(matrixName + ".scaling", 1);\n\n    matrix.setZero();\n\n    const size_t rows = matrix.rows();\n    const size_t cols = matrix.cols();\n\n    boost::property_tree::ptree matrix_pt = pt.get_child(matrixName);\n\n    const size_t num_entries = matrix_pt.size() - matrix_pt.count("scaling");\n    if (num_entries < size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Missing entries in matrix type: {}!\\n", matrixName));\n    }\n    if (num_entries > size_t(matrix.size()))\n    {\n        throw std::runtime_error(fmt::format("Redundant entries in matrix type: {}!\\n", matrixName));\n    }\nHuman:     void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "nondimensionalize" in the "RocketQuat" class of the "scpp::models" namespace is responsible for removing mass and length dimensions from all function parameters. It is a virtual function that needs to be implemented by the derived class. This function is called before solving the optimization problem to ensure that the optimization variables are dimensionless. The function "redimensionalize" performs the opposite operation, adding mass and length dimensions to all function parameters, and is also a virtual function that needs to be implemented by the derived class. The function "getOperatingPoint" returns the operating point of the system, usually an equilibrium point for linearization, and is also a virtual function that needs to be implemented by the derived class. These functions are part of the "SCAlgorithm" class, which solves the sequential convex programming (SCP) problem for optimal control of nonlinear systems. The "SCAlgorithm" class takes a "Model" object as input, which represents the dynamic model of the system, and generates a set of solutions that satisfy the optimization constraints. The "SCAlgorithm" class also provides functions to get all solutions and calculate defects, which are used to evaluate the quality of the solutions. The "ParameterServer" class is used to load parameters from a file and provides functions to load matrices and load parameters from a file. The "Model" class represents the dynamic model of the system and provides functions to simulate the system, update the problem parameters, and load parameters from a file. The "Model" class also provides functions to nondimensionalize and redimensionalize the trajectory data, which are used to convert the optimization variables to dimensionless form before solving the optimization problem. The "Model" class has two derived classes, "RocketQuat" and "Rocket2d", which represent different types of rockets. The "RocketQuat" class represents a four-degree-of-freedom (4-DOF) rocket with quaternion attitude representation, while the "Rocket2d" class represents a two-degree-of-freedom (2-DOF) rocket with Euler angles attitude representation. Both classes provide functions to load parameters from a file, update the problem parameters, and nondimensionalize and redimensionalize the trajectory data. The "SCAlgorithm" class also provides functions to load parameters from a file and update the problem parameters. The "SCAlgorithm" class'}

scpp::models::RocketQuat::nondimensionalizeTrajectory

{'input': '    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'}), Document(page_content='void RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n#pragma once\n\n#include <cstddef>\n\nnamespace scpp\n{\n\ntemplate <class Model>\nstruct TrajectoryData\n{\n    typename Model::state_vector_v_t X;\n    typename Model::input_vector_v_t U;\n    double t;\n\n    void initialize(size_t K, bool interpolate_input);\n\n    bool interpolatedInput() const;\n\n    typename Model::input_vector_t inputAtTime(double t) const;\n    typename Model::state_vector_t approxStateAtTime(double t) const;\n\n    size_t n_X() const;\n    size_t n_U() const;\n};\n\ntemplate <class Model>\n\nvoid RocketQuat::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                               state_vector_v_t &,\n                                               input_vector_v_t &U0)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\n        // Initial state\n        socp->addConstraint(cvx::equalTo(v_X.col(0), cvx::dynpar(p.x_init)));\n\n        // Final State\n        // mass and roll are free\n        for (size_t i : {1, 2, 3,\n                         4, 5, 6,\n                         8, 9,\n                         11, 12, 13})\n        {\n            socp->addConstraint(cvx::equalTo(v_X(i, v_X.cols() - 1), cvx::dynpar(p.x_final(i))));\n        }\n\n        // State Constraints:\n        // Mass\n        socp->addConstraint(cvx::greaterThan(v_X.row(0), cvx::dynpar(p.x_final(0))));\nHuman:     void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function RocketQuat::getNewModelParameters extracts the new values of the model parameters from the user input and stores them in the parameter vector. It is called by the user when they want to modify the model parameters. The function updates the problem parameters and is part of the RocketQuat class, which is a subclass of the SystemModel template class. The function is used in conjunction with the loadParameters function, which loads the initial parameter values from a file, and the getOperatingPoint function, which returns the operating point of the system. The function also participates in the nondimensionalize and redimensionalize functions, which remove and add mass and length dimensions to the function parameters, respectively. These functions are used for scaling the trajectory data to fit different simulation scenarios.'}

scpp::models::RocketQuat::redimensionalize

{'input': '    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocket2d.hpp'}), Document(page_content='void RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCAlgorithm.cpp'}), Document(page_content='discretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/src/SCvxAlgorithm.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid loadParameters();\n\n    struct Parameters\n    {\n        double m_scale;\n        double r_scale;\n\n        double m;\n        double J_B;\n        Eigen::Vector2d g_I;\n        Eigen::Vector2d r_T_B;\n        double T_min;\n        double T_max;\n\n        double gamma_gs;\n        double tan_gamma_gs;\n        double gimbal_max;\n        double theta_max;\n        double w_B_max;\n\n        double eta_init;\n        double eta_final;\n\n        state_vector_t x_init;\n        state_vector_t x_final;\n        double final_time;\n\n        bool constrain_initial_final;\n        bool add_slack_variables;\n\n        void loadFromFile(const std::string &path);\n\n        void nondimensionalize();\n\n        void redimensionalize();\n    } p;\n};\n\n} // namespace scpp::models\n\nvoid RocketQuat::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        bool random_initial_state;\n        double I_sp;\n        double m_init, m_dry;\n        Eigen::Vector3d r_init, v_init, rpy_init, w_init;\n        Eigen::Vector3d r_final, v_final, rpy_final, w_final;\n\nvoid SCAlgorithm::getAllSolutions(std::vector<trajectory_data_t> &all_trajectories)\n    {\n        if (nondimensionalize)\n        {\n            auto all_td_redim = all_td;\n            for (auto &td_redim : all_td_redim)\n            {\n                model->redimensionalizeTrajectory(td_redim);\n            }\n            all_trajectories = all_td_redim;\n        }\n        else\n        {\n            all_trajectories = all_td;\n        }\n    }\n\n    std::vector<bool> SCAlgorithm::calculateDefects()\n    {\n        std::vector<bool> pattern;\n\n        for (size_t k = 0; k < K - 1; k++)\n        {\n            Model::state_vector_t x = td.X.at(k);\n            const Model::input_vector_t u0 = td.U.at(k);\n            const Model::input_vector_t u1 = interpolate_input ? td.U.at(k + 1) : u0;\n\n            const double dt = td.t / (K - 1);\n            simulate(model, dt, u0, u1, x);\n\n            const double defect = (x - td.X.at(k + 1)).squaredNorm();\n\ndiscretization::multipleShooting(model, td, dd);\n\n        print("{:<{}}{:.2f}ms\\n", "Time, discretization:", 50, toc(timer));\n\n        bool converged = false;\n\n        while (true)\n        {\n            // solve problem\n            const trajectory_data_t old_td = td;\n\n            print("\\n");\n            print("Solving problem.\\n");\n            timer = tic();\n            const bool success = solver->solve(false);\n            print("Solver message:\\n");\n            print("> {}\\n", solver->getResultString());\n            print("{:<{}}{:.2f}ms\\n", "Time, solver:", 50, toc(timer));\n            print("\\n");\n\n            if (not success)\n            {\n                print("Solver failed to find a solution. Terminating.\\n");\n                std::terminate();\n            }\n\n            readSolution();\n\n            // compare linear and nonlinear costs\n            timer = tic();\n            const double nonlinear_cost_dynamics = getNonlinearCost();\nHuman:     void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    Function "nondimensionalize" and "redimensionalize" in the "Parameters" struct of the "RocketQuat" model in the "scpp::models" namespace are used to remove and add mass and length dimensions respectively from all function parameters. These functions have to be implemented by the derived class as they are declared as pure virtual functions. The "getOperatingPoint" function in the same struct is used to obtain the operating point, usually an equilibrium point for linearization. The "RocketQuat" model is a nonlinear dynamic model for a spacecraft with a quaternion attitude representation. It is used in the "SCAlgorithm" class for solving optimal control problems using the "CVXGEN" optimization framework. The "SCAlgorithm" class has functions for loading parameters, getting all solutions, calculating defects, and solving the problem using the "MOSEK" solver. The "discretization::multipleShooting" function is used for multiple shooting discretization. The "Model" class is an abstract base class for dynamic models, and the "RocketQuat" model inherits from it. The "trajectory_data_t" and "state_vector_t" structures are used to store trajectory data and state vectors respectively. The "input_vector_t" structure is used to store input vectors. The "ParameterServer" class is used for loading parameters from a file. The "cvx::Box" and "cvx::EqualTo" constraints are used for adding constraints to the optimization problem. The "cvx::DynPar" and "cvx::Par" classes are used for dynamic and parameter variables respectively. The "cvx::Problem" class is used for defining the optimization problem. The "cvx::Solver" class is used for solving the optimization problem. The "cvx::Variable" class is used for defining variables. The "cvxgen" and "MOSEK" libraries are used for optimization. The "Eigen" library is used for linear algebra operations. The "boost" library is used for serialization and deserialization. The "chrono" library is used for timing measurements. The "iomanip" library is used for formatting output. The "limits" library is used for floating-point limits. The "stdexcept" library is used for exceptions. The "string" library is used for string manipulation. The "vector'}

scpp::models::RocketQuat::redimensionalizeTrajectory

{'input': '    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='void RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemModel.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/SCAlgorithm.hpp'}), Document(page_content='void TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/trajectoryData.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nvoid RocketQuat::getNewModelParameters(param_vector_t &param)\n    {\n        param << p.alpha_m, p.g_I, p.J_B, p.r_T_B;\n\n        updateProblemParameters();\n    }\n\n    void RocketQuat::nondimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) /= p.m_scale;\n            x.segment<6>(1) /= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() /= p.m_scale * p.r_scale;\n            u(3) /= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\nvoid Rocket2d::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x.head(4) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u(1) *= p.m_scale * p.r_scale;\n        }\n    }\n\n    void Rocket2d::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            td.X.at(k) = alpha1 * p.x_init + alpha2 * p.x_final;\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0, (p.T_max + p.T_min) / 2;\n        }\n\n        td.t = p.final_time;\n    }\n\n    void Rocket2d::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\n    void Rocket2d::getNewModelParameters(param_vector_t &par)\n    {\n        par << p.m, p.J_B, p.g_I, p.r_T_B;\n\n        p.tan_gamma_gs = std::tan(p.gamma_gs);\n    }\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\n/**\n     * @brief Function to remove mass and length dimensions from all function parameters.\n     * \n     */\n    virtual void nondimensionalize()\n    {\n        throw std::runtime_error("nondimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Function to add mass and length dimensions to all function parameters.\n     * \n     */\n    virtual void redimensionalize()\n    {\n        throw std::runtime_error("redimensionalize: This function has to be implemented by the derived class.");\n    };\n\n    /**\n     * @brief Get the operating point of the system. Usually an equilibrium point for linearization.\n     * \n     */\n    virtual void getOperatingPoint(state_vector_t &, input_vector_t &)\n    {\n        throw std::runtime_error("getOperatingPoint: This function has to be implemented by the derived class.");\n    };\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nclass SCAlgorithm\n{\npublic:\n    /**\n     * @brief Construct a new SC solver.\n     * \n     * @param model     The system model.\n     */\n    explicit SCAlgorithm(Model::ptr_t model);\n\n    /**\n     * @brief Initializes the algorithm. Has to be called before solving the problem.\n     * \n     */\n    void initialize();\n\n    /**\n     * @brief Solves the system.\n     * \n     * @param warm_start    Whether to reuse the last computed trajectory.\n     */\n    void solve(bool warm_start = false);\n\n    /**\n     * @brief Get the solution variables object.\n     * \n     * @param X     The state trajectory.\n     * @param U     The input trajectory.\n     * @param t     The final time.\n     */\n    void getSolution(trajectory_data_t &trajectory) const;\n\n    /**\n     * @brief Get the solution from each iteration\n     * \n     */\n    void getAllSolutions(std::vector<trajectory_data_t> &all_trajectories);\n\nvoid TrajectoryData<Model>::initialize(size_t K, bool interpolate_input)\n{\n    X.resize(K);\n    U.resize(interpolate_input ? K : K - 1);\n    t = 0.;\n}\n\ntemplate <class Model>\nbool TrajectoryData<Model>::interpolatedInput() const\n{\n    return U.size() == X.size();\n}\n\ntemplate <class Model>\ntypename Model::input_vector_t TrajectoryData<Model>::inputAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\n\n    if (t == this->t)\n    {\n        return U.back();\n    }\n\n    const double dt = this->t / (n_X() - 1);\n    double interpolate_value = std::fmod(t, dt) / dt;\n    const size_t i = t / dt;\n\n    const typename Model::input_vector_t u0 = U.at(i);\n    const typename Model::input_vector_t u1 = interpolatedInput() ? U.at(i + 1) : U.at(i);\n\n    return u0 + interpolate_value * (u1 - u0);\n}\n\ntemplate <class Model>\ntypename Model::state_vector_t TrajectoryData<Model>::approxStateAtTime(double t) const\n{\n    t = std::clamp(t, 0., this->t);\nHuman:     void RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)\n    {\n        for (auto &x : td.X)\n        {\n            x(0) *= p.m_scale;\n            x.segment<6>(1) *= p.r_scale;\n        }\n        for (auto &u : td.U)\n        {\n            u.head<3>() *= p.m_scale * p.r_scale;\n            u(3) *= p.m_scale * p.r_scale * p.r_scale;\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function "RocketQuat::redimensionalizeTrajectory(trajectory_data_t &td)" is used to restore the mass and length dimensions to the trajectory data "td". It applies scaling factors to the mass, position, and velocity components of the state vector and the input vector. This function is called after non-dimensionalization to prepare the trajectory data for simulation or analysis in the original physical units. It takes a reference to the trajectory data as input and modifies its contents in place.'}

scpp::models::RocketQuat::systemFlowMap

{'input': '    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\n        f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='class RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'}), Document(page_content='class SystemDynamics\n{\npublic:\n    using state_vector_t = Eigen::Matrix<double, STATE_DIM, 1>;\n    using state_matrix_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM>;\n    using input_vector_t = Eigen::Matrix<double, INPUT_DIM, 1>;\n    using input_matrix_t = Eigen::Matrix<double, INPUT_DIM, INPUT_DIM>;\n    using control_matrix_t = Eigen::Matrix<double, STATE_DIM, INPUT_DIM>;\n    using feedback_matrix_t = Eigen::Matrix<double, INPUT_DIM, STATE_DIM>;\n    using param_vector_t = Eigen::Matrix<double, PARAM_DIM, 1>;\n    using dynamic_vector_t = Eigen::Matrix<double, Eigen::Dynamic, 1>;\n    using dynamic_matrix_t = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;\n    using dynamic_vector_map_t = Eigen::Map<dynamic_vector_t>;\n\n    using state_vector_v_t = std::vector<state_vector_t>;\n    using input_vector_v_t = std::vector<input_vector_t>;\n    using state_matrix_v_t = std::vector<state_matrix_t>;\n    using control_matrix_v_t = std::vector<control_matrix_t>;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'}), Document(page_content='x_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/systemDynamics.hpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\n#include "common.hpp"\n#include "rocketQuat.hpp"\n\nnamespace scpp::models\n{\n\n    void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\nclass RocketQuat : public SystemModel<RocketQuat, STATE_DIM, INPUT_DIM, PARAM_DIM>\n{\npublic:\n    RocketQuat() = default;\n\n    inline static const std::string modelName = "RocketQuat";\n\n    void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) override;\n\n    void getInitializedTrajectory(trajectory_data_t &td) override;\n\n    void addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                   state_vector_v_t &X0,\n                                   input_vector_v_t &U0) override;\n\n    void nondimensionalize() override;\n\n    void redimensionalize() override;\n\n    void nondimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void redimensionalizeTrajectory(trajectory_data_t &td) override;\n\n    void getNewModelParameters(param_vector_t &param) override;\n\n    void loadParameters();\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nf.segment<2>(0) << v;\n        f.segment<2>(2) << 1. / m * (R_I_B * T_B) + g_I;\n        f(4) = w;\n        f(5) = 1. / J_B * (r_T_B.x() * T_B.y() - r_T_B.y() * T_B.x());\n    }\n\n    void Rocket2d::getOperatingPoint(state_vector_t &x, input_vector_t &u)\n    {\n        x.setZero();\n        u << 0, -p.g_I * p.m;\n    }\n\n    void Rocket2d::addApplicationConstraints(std::shared_ptr<cvx::OptimizationProblem> socp,\n                                             state_vector_v_t &,\n                                             input_vector_v_t &)\n    {\n        cvx::MatrixX v_X, v_U;\n        socp->getVariable("X", v_X);\n        socp->getVariable("U", v_U);\n\nclass SystemDynamics\n{\npublic:\n    using state_vector_t = Eigen::Matrix<double, STATE_DIM, 1>;\n    using state_matrix_t = Eigen::Matrix<double, STATE_DIM, STATE_DIM>;\n    using input_vector_t = Eigen::Matrix<double, INPUT_DIM, 1>;\n    using input_matrix_t = Eigen::Matrix<double, INPUT_DIM, INPUT_DIM>;\n    using control_matrix_t = Eigen::Matrix<double, STATE_DIM, INPUT_DIM>;\n    using feedback_matrix_t = Eigen::Matrix<double, INPUT_DIM, STATE_DIM>;\n    using param_vector_t = Eigen::Matrix<double, PARAM_DIM, 1>;\n    using dynamic_vector_t = Eigen::Matrix<double, Eigen::Dynamic, 1>;\n    using dynamic_matrix_t = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;\n    using dynamic_vector_map_t = Eigen::Map<dynamic_vector_t>;\n\n    using state_vector_v_t = std::vector<state_vector_t>;\n    using input_vector_v_t = std::vector<input_vector_t>;\n    using state_matrix_v_t = std::vector<state_matrix_t>;\n    using control_matrix_v_t = std::vector<control_matrix_t>;\n\nx_init(0) /= m_scale;\n        x_init.segment(1, 3) /= r_scale;\n        x_init.segment(4, 3) /= r_scale;\n\n        x_final(0) /= m_scale;\n        x_final.segment(1, 3) /= r_scale;\n        x_final.segment(4, 3) /= r_scale;\n\n        T_min /= m_scale * r_scale;\n        T_max /= m_scale * r_scale;\n        t_max /= m_scale * r_scale * r_scale;\n    }\n\n    void RocketQuat::Parameters::redimensionalize()\n    {\n        alpha_m /= r_scale;\n        r_T_B *= r_scale;\n        g_I *= r_scale;\n        J_B *= m_scale * r_scale * r_scale;\n\n        x_init(0) *= m_scale;\n        x_init.segment(1, 3) *= r_scale;\n        x_init.segment(4, 3) *= r_scale;\n\n        x_final(0) *= m_scale;\n        x_final.segment(1, 3) *= r_scale;\n        x_final.segment(4, 3) *= r_scale;\n\n        T_min *= m_scale * r_scale;\n        T_max *= m_scale * r_scale;\n        t_max *= m_scale * r_scale * r_scale;\n    }\n\n} // namespace scpp::models\n\n// do SLERP for quaternion\n            auto q0_ = p.x_init.segment<4>(7);\n            auto q1_ = p.x_final.segment<4>(7);\n            Eigen::Quaterniond q0(q0_(0), q0_(1), q0_(2), q0_(3));\n            Eigen::Quaterniond q1(q1_(0), q1_(1), q1_(2), q1_(3));\n            Eigen::Quaterniond qs = q0.slerp(alpha2, q1);\n            td.X.at(k).segment<4>(7) << qs.w(), qs.vec();\n\n            // angular velocity\n            td.X.at(k).segment<3>(11) = alpha1 * p.x_init.segment<3>(11) + alpha2 * p.x_final.segment<3>(11);\n        }\n\n        for (auto &u : td.U)\n        {\n            u << 0., 0., (p.T_max - p.T_min) / 2., 0.;\n        }\n\n        td.t = p.final_time;\n    }\n\n/**\n     * @brief The state derivative function. Has to be implemented by the derived class. All types have to be scalar_ad_t.\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    virtual void systemFlowMap(\n        const state_vector_ad_t &x,\n        const input_vector_ad_t &u,\n        const param_vector_ad_t &par,\n        state_vector_ad_t &f) = 0;\n\n    /**\n     * @brief Compute the state derivative f(x,u)\n     * \n     * @param x \n     * @param u \n     * @param f \n     */\n    void computef(const state_vector_t &x, const input_vector_t &u, state_vector_t &f);\n\n    /**\n     * @brief Compute the state and control Jacobians A(x,u) and B(x,u)\n     * \n     * @param x \n     * @param u \n     * @param A \n     * @param B \n     */\n    void computeJacobians(const state_vector_t &x,\n                          const input_vector_t &u,\n                          state_matrix_t &A,\n                          control_matrix_t &B);\nHuman:     void RocketQuat::systemFlowMap(const state_vector_ad_t &x,\n                                   const input_vector_ad_t &u,\n                                   const param_vector_ad_t &par,\n                                   state_vector_ad_t &f)\n    {\n        using T = scalar_ad_t;\n\n        auto alpha_m = par(0);\n        auto g_I = par.segment<3>(1);\n        auto J_B_inv = par.segment<3>(4).asDiagonal().inverse();\n        auto r_T_B = par.segment<3>(7);\n        // = 10 parameters\n\n        // state variables\n        auto m = x(0);\n        auto v = x.segment<3>(4);\n        auto q = x.segment<4>(7);\n        auto w = x.segment<3>(11);\n\n        auto thrust = u.head<3>();\n        auto torque = Eigen::Matrix<T, 3, 1>(T(0.), T(0.), u(3));\n\n        auto R_I_B = Eigen::Quaternion<T>(q(0), q(1), q(2), q(3))\n                         .toRotationMatrix();\n\n        f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `RocketQuat::systemFlowMap` is a part of the `scpp::models` namespace in the C++ codebase. It takes a state vector `x`, an input vector `u`, and a parameter vector `par` as arguments, and returns the derivative of the state vector `f`. The function uses 10 parameters, including `alpha_m`, `g_I`, `J_B_inv`, and `r_T_B`. The state variables include `m`, `v`, `q`, and `w`. The input vector `u` contains the thrust and torque components. The function calculates the derivative of the state variables based on the given inputs and parameters. The function `computef` and `computeJacobians` are also mentioned, but their functionality is not described in detail.'}

scpp::models::RocketQuat::updateProblemParameters

{'input': '    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    ', 'context': [Document(page_content='if (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='if (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='void RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='f(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocketQuat.cpp'}), Document(page_content='struct DynamicParameters\n    {\n        double tilt_const;\n        double gs_const;\n        double gimbal_const;\n        Eigen::MatrixXd thrust_const;\n        input_vector_v_t *U0_ptr;\n    } p_dyn;\n\nprivate:\n    void updateProblemParameters();\n};\n\n} // namespace scpp::models', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/include/rocketQuat.hpp'}), Document(page_content='#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_core/include/activeModel.hpp'}), Document(page_content='// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp/src/LQR_sim.cpp'}), Document(page_content='void Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);', metadata={'language': 'cpp', 'source': '/Users/adelinemoll/Documents/LLM/LangChain/SCpp/scpp_models/src/rocket2d.cpp'})], 'answer': 'System: Summarize the function provided by the user based on this context from the entire codebase:\n\nif (p.exact_minimum_thrust)\n        {\n            p_dyn.U0_ptr = &U0;\n            p_dyn.thrust_const.resize(3, U0.size());\n\n            // Linearized Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(cvx::dynpar(p_dyn.thrust_const).cwiseProduct(v_U.topRows(3)).colwise().sum(),\n                                                 cvx::dynpar(p.T_min)));\n        }\n        else\n        {\n            // Simplified Minimum Thrust\n            socp->addConstraint(cvx::greaterThan(v_U.row(2), cvx::dynpar(p.T_min)));\n        }\n\n        // Maximum Thrust\n        socp->addConstraint(cvx::lessThan(v_U.topRows(3).colwise().norm(), cvx::dynpar(p.T_max)));\n\n        // Maximum Gimbal Angle\n        socp->addConstraint(cvx::lessThan(v_U.topRows(2).colwise().norm(),\n                                          cvx::dynpar(p_dyn.gimbal_const) * v_U.row(2)));\n\nif (p.enable_roll_control)\n        {\n            socp->addConstraint(cvx::box(-cvx::dynpar(p.t_max), v_U.row(3), cvx::dynpar(p.t_max)));\n        }\n        else\n        {\n            socp->addConstraint(cvx::equalTo(v_X.row(13), 0.));\n            socp->addConstraint(cvx::equalTo(v_U.row(3), 0.));\n        }\n    }\n\n    void RocketQuat::nondimensionalize()\n    {\n        p.nondimensionalize();\n    }\n\n    void RocketQuat::redimensionalize()\n    {\n        p.redimensionalize();\n    }\n\n    void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\nvoid RocketQuat::Parameters::randomizeInitialState()\n    {\n        // std::mt19937 eng(time(nullptr));\n        // auto dist = std::uniform_real_distribution<double>(-1., 1.);\n\n        // // mass\n        // x_init(0) *= 1.;\n\n        // // position\n        // x_init(1) *= dist(eng);\n        // x_init(2) *= dist(eng);\n        // x_init(3) *= 1.;\n\n        // // velocity\n        // x_init(4) *= dist(eng);\n        // x_init(5) *= dist(eng);\n        // x_init(6) *= 1. + 0.2 * dist(eng);\n\n        // // orientation\n        // double rx = dist(eng) * rpy_init.x();\n        // double ry = dist(eng) * rpy_init.y();\n        // double rz = rpy_init.z();\n        // Eigen::Vector3d euler(rx, ry, rz);\n        // x_init.segment(7, 3) << quaternionToVector(eulerToQuaternionXYZ(euler));\n    }\n\n    void RocketQuat::loadParameters()\n    {\n        p.loadFromFile(getParameterFolder() + "/model.info");\n    }\n\nf(0) = -alpha_m * thrust.norm();\n        f.segment<3>(1) << v;\n        f.segment<3>(4) << 1. / m * R_I_B * thrust + g_I;\n        f.segment<4>(7) << T(0.5) * omegaMatrix<T>(w) * q;\n        f.segment<3>(11) << J_B_inv * (r_T_B.cross(thrust) + torque) - w.cross(w);\n    }\n\n    void RocketQuat::getInitializedTrajectory(trajectory_data_t &td)\n    {\n        for (size_t k = 0; k < td.n_X(); k++)\n        {\n            const double alpha1 = double(td.n_X() - k) / td.n_X();\n            const double alpha2 = double(k) / td.n_X();\n\n            // mass, position and linear velocity\n            td.X.at(k)(0) = alpha1 * p.x_init(0) + alpha2 * p.x_final(0);\n            td.X.at(k).segment(1, 6) = alpha1 * p.x_init.segment(1, 6) + alpha2 * p.x_final.segment(1, 6);\n\nstruct DynamicParameters\n    {\n        double tilt_const;\n        double gs_const;\n        double gimbal_const;\n        Eigen::MatrixXd thrust_const;\n        input_vector_v_t *U0_ptr;\n    } p_dyn;\n\nprivate:\n    void updateProblemParameters();\n};\n\n} // namespace scpp::models\n\n#pragma once\n\n\n// ---\n\n// #include "rocketQuat.hpp"\n// using Model = scpp::models::RocketQuat;\n\n#include "rocket2d.hpp"\nusing Model = scpp::models::Rocket2d;\n\n// ---\n\nusing discretization_data_t = Model::discretization_data_t;\nusing trajectory_data_t = Model::trajectory_data_t;\n\n// constrain input\n        const double c = std::tan(model->p.gimbal_max) * u.z();\n        if (u.head<2>().norm() > c)\n        {\n            u.head<2>() = c * u.head<2>().normalized();\n        }\n        if (u.norm() > model->p.T_max)\n        {\n            u = model->p.T_max * u.normalized();\n        }\n\n        // move time forward\n        scpp::simulate(model, time_step, u, u, x);\n        t += time_step;\n\n        X_sim.push_back(x);\n        U_sim.push_back(u);\n        t_sim.push_back(t);\n\n        sim_step++;\n\n        if ((x - model->p.x_final).norm() < 0.02)\n        {\n            break;\n        }\n    }\n    fmt::print("\\n");\n    fmt::print("{:=^{}}\\n", fmt::format("<SIMULATION FINISHED>"), 60);\n    fmt::print("{:<{}}{:.2f}s\\n", "Runtime:", 50, 0.001 * toc(run_timer));\n    fmt::print("{:<{}}{:.2f}s\\n", "Simulated time:", 50, t);\n    const double freq = double(sim_step) / t;\n    fmt::print("{:<{}}{:.2f}Hz\\n", "Average frequency:", 50, freq);\n    fmt::print("\\n");\n\nvoid Rocket2d::Parameters::loadFromFile(const std::string &path)\n    {\n        ParameterServer param(path);\n\n        param.loadMatrix("g_I", g_I);\n        param.loadScalar("J_B", J_B);\n        param.loadMatrix("r_T_B", r_T_B);\n\n        Eigen::Vector2d r_init, v_init;\n        Eigen::Vector2d r_final, v_final;\n        double w_init, w_final;\n\n        param.loadMatrix("r_init", r_init);\n        param.loadMatrix("v_init", v_init);\n        param.loadScalar("eta_init", eta_init);\n        param.loadScalar("w_init", w_init);\n\n        param.loadMatrix("r_final", r_final);\n        param.loadMatrix("v_final", v_final);\n        param.loadScalar("eta_final", eta_final);\n        param.loadScalar("w_final", w_final);\n\n        param.loadScalar("final_time", final_time);\nHuman:     void RocketQuat::updateProblemParameters()\n    {\n        p_dyn.gimbal_const = std::tan(p.gimbal_max);\n        p_dyn.gs_const = std::tan(p.gamma_gs);\n        p_dyn.tilt_const = std::sqrt((1. - std::cos(p.theta_max)) / 2.);\n\n        for (size_t k = 0; k < size_t(p_dyn.thrust_const.cols()); k++)\n        {\n            p_dyn.thrust_const.col(k) = p_dyn.U0_ptr->at(k).head<3>().normalized();\n        }\n    }\n\n    Generate a concise summary of the provided C++ function. \n    Use the provided context from other parts of the codebase if it helps summarize the function. \n    Keep the summary to 5 sentences or less. \n\n    Instructions: \n    - Provide one paragraph.\n    - Use 5 sentences or less.\n    - Describe dependencies, important functions and classes, and relevant information from comments.\n\n    Restrictions:\n    - Do not say "Summary" or "Output".\n    - Do not engage in any conversation.\n    - Only describe the provided C++ function.\n    - Start directly with the summary, with no precursors.\n    \n    The function `updateProblemParameters()` in the `RocketQuat` class updates the dynamic parameters `gimbal_const`, `gs_const`, and `tilt_const` based on the values of `gimbal_max`, `gamma_gs`, and `theta_max` respectively. It also populates the `thrust_const` matrix with the normalized first three components of the vectors stored in the `U0_ptr` pointer. This function is called by the `RocketQuat` constructor and the `loadParameters()` function.'}

